<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="google-site-verification" content="DO25iswIsaKZ5NZbYreVDjWtBKTyo1yFAROjSRcJD64">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.loli.net/css?family=Lato:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Flink,">





  <link rel="alternate" href="/atom.xml" title="Aitozi" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="关于Flink中watermark工作原理代码分析">
<meta name="keywords" content="Flink">
<meta property="og:type" content="article">
<meta property="og:title" content="flink-watermark">
<meta property="og:url" content="http://www.aitozi.com/flink-watermark.html">
<meta property="og:site_name" content="Aitozi">
<meta property="og:description" content="关于Flink中watermark工作原理代码分析">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-03-14T17:05:18.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="flink-watermark">
<meta name="twitter:description" content="关于Flink中watermark工作原理代码分析">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.aitozi.com/flink-watermark.html">





  <title>flink-watermark | Aitozi</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Aitozi</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.aitozi.com/flink-watermark.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aitozi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aitozi">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">flink-watermark</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-10T15:59:23+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/flink-watermark.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="flink-watermark.html" itemprop="commentCount"></span>
                </a>
                <span class="post-meta-divider">|</span>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-eye"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  3.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  12
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>关于Flink中watermark工作原理代码分析</p>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>waterMark，latency，checkpoint这三者实现方式都是上游节点逐步广播消息给下游节点来处理的行为（都是在流中插入一种特殊的数据结构来做处理）</p>
<h3 id="时间语义"><a href="#时间语义" class="headerlink" title="时间语义"></a>时间语义</h3><p>谈及watermark就要先从Flink支持的时间语义说起，Flink支持三种时间语义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process time:指的系统处理对应数据时的系统时间。他是最简单的一种实现，由于不需要额外的协调，因性能最好</span><br><span class="line">event time:是指数据中携带的时间，而不是数据到达的时间。因此时间的进度完全取决于数据，而不是系统时间。使用event time必须指定生成eventTime和watermark的方式。因为他一般会等待迟到的数据，因此一定会有一定的延时</span><br><span class="line">ingestion time:是指数据进入flink的时间，在source处插入的时间，和process time一样无法处乱序事件</span><br></pre></td></tr></table></figure>
<p>对于eventtime和ingestion time两种语义到达的数据有可能乱序的。从事件产生（例如日志采集数据中的乱序日志），到流经source，再到operator，中间是有一个过程时间的。虽然大部分情况下，流到operator的数据都是按照事件产生的时间顺序来的，但是也不排除由于网络、背压等原因，导致乱序的产生（out-of-order或者说late element）。<br>但是对于late element，我们又不能无限期的等下去，必须要有个机制来保证一个特定的时间后，必须触发window去进行计算了。这个特别的机制，就是watermark，它告诉了算子时间不大于 WaterMark 的消息不应该再被接收【如果出现意味着延迟到达】。也就是说水位线以下的数据均已经到达。WaterMark 从源算子开始 emit，并逐级向下游算子传递。当源算子关闭时，会发射一个携带 Long.MAX_VALUE 值时间戳的 WaterMark，下游算子接收到之后便知道不会再有消息到达。</p>
<h3 id="waterMark产生方式"><a href="#waterMark产生方式" class="headerlink" title="waterMark产生方式"></a>waterMark产生方式</h3><p>waterMark的产生:有两种方式来产生watermark和timestamp</p>
<ol>
<li>在数据源处直接进行assign timestamp 和generate watermark</li>
<li>通过timestamp和watermark generate operator来产生，如果使用了timestamp assigner和watermark generator在source处产生的timestamp和watermark会被覆盖。</li>
<li>其实这两种最终的实现方式还是一样的！即第一种也是在source处分配了timestampAssigner</li>
</ol>
<h4 id="方法一-在数据源处产生发送"><a href="#方法一-在数据源处产生发送" class="headerlink" title="方法一 在数据源处产生发送"></a>方法一 在数据源处产生发送</h4><p>目前实现了在source提取时间和产生operator的只有0.10版本的kafka fetcher中实现<br>首先根据应用<code>StreamExecutionEnvironment#setStreamTimeCharacteristic</code>设置的时间语义（存储于<code>StreamConfig</code>类）来获取<br>对应的sourceContext，sourceContext接口是sourceFunction发送数据的抽象，有三个实现类，根据时间语义划分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (timeCharacteristic) &#123;</span><br><span class="line">            <span class="keyword">case</span> EventTime:</span><br><span class="line">                ctx = <span class="keyword">new</span> ManualWatermarkContext&lt;&gt;(checkpointLock, output);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IngestionTime:</span><br><span class="line">                ctx = <span class="keyword">new</span> AutomaticWatermarkContext&lt;&gt;(processingTimeService, checkpointLock, output, watermarkInterval);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ProcessingTime:</span><br><span class="line">                ctx = <span class="keyword">new</span> NonTimestampContext&lt;&gt;(checkpointLock, output);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.valueOf(timeCharacteristic));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br></pre></td></tr></table></figure>
<p>这里我们就考虑eventTime的情况。<br>在kafka AbstractFetcher中还提供了三种模式来控制自己生产时间戳和watermark</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NO_TIMESTAMPS_WATERMARKS: fetcher 不生产 timestamp 和 watermarks</span><br><span class="line">PERIODIC_WATERMARKS: fetcher 阶段性定时生产 watermarks</span><br><span class="line">PUNCTUATED_WATERMARKS: fetcher 生产标记 watermark 【按照特定的消息字段值触发】</span><br></pre></td></tr></table></figure>
<p>这里的区分方式来自于<code>FlinkKafkaConsumerBase#assignTimestampsAndWatermarks</code>分配的<code>AssignerWithPunctuatedWatermarks</code>或<code>AssignerWithPeriodicWatermarks</code> 也就是assigner决定了产生方式，这其实就是把方法二给封装到了KafkaConsumerBase里面！当然这个也需要用户在创建consumer之后自定义一个assigner。</p>
<h4 id="方法二-使用TimestampAssigner来实现"><a href="#方法二-使用TimestampAssigner来实现" class="headerlink" title="方法二 使用TimestampAssigner来实现"></a>方法二 使用TimestampAssigner来实现</h4><p>TimestampAssinger是接收一个流，并产生一个新的流带上了时间戳和watermark，如果原来的流已经带有了timestamp和watermark那么这个将会被覆盖。timestamp assinger只需要在关于时间的操作之前加上即可。</p>
<p>flink通过接口<code>TimestampAssigner</code>来让用户依据消息的格式自己抽取可能被用于 WaterMark的timestamp，它只定义了一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(T element, <span class="keyword">long</span> previousElementTimestamp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>previousElementTimestamp这个参数传入的是什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> newTimestamp = userFunction.extractTimestamp(value, </span><br><span class="line">				element.hasTimestamp() ? element.getTimestamp() : Long.MIN_VALUE);</span><br><span class="line">因此如果一个元素如果已经带有timestamp，比如在source处已经分配，那么在这里处理的时候会被覆盖掉。</span><br></pre></td></tr></table></figure>
<p>而<code>TimestampAssigner</code>的两个继承接口<code>AssignerWithPunctuatedWatermarks</code>以及 <code>AssignerWithPeriodicWatermarks</code> 定义了waterMark生成的两种典型方式。</p>
<h5 id="AssignerWithPeriodicWatermarks"><a href="#AssignerWithPeriodicWatermarks" class="headerlink" title="AssignerWithPeriodicWatermarks"></a>AssignerWithPeriodicWatermarks</h5><p><code>AssignerWithPeriodicWatermarks</code>是周期性的产生watermark，每过一定间隔   <code>ExecutionConfig#getAutoWatermarkInterval()</code>，系统会调用<code>getCurrentWatermark</code>来获取最新的waterMark值，如果新的waterMark值有增长那么就会发送一个新的waterMark，如果没有新的元素进来，那么getCurrentWatermark则不会被周期性的调用，这个接口的好处是，可以定义最大乱序时间，减少因为数据延迟到达而被时间窗口丢弃的行为，实现类<code>BoundedOutOfOrdernessTimestampExtractor</code></p>
<h5 id="AssignerWithPunctuatedWatermarks"><a href="#AssignerWithPunctuatedWatermarks" class="headerlink" title="AssignerWithPunctuatedWatermarks"></a>AssignerWithPunctuatedWatermarks</h5><p><code>AssignerWithPunctuatedWatermarks</code>的使用场景是针对在接收到特定的elements之后才触发更新waterMark的操作。比如有一个流中有一些元素带有flag表示没有晚于这个元素时间的元素了,那么他的实现代码是这样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatermarkOnFlagAssigner</span> <span class="keyword">implements</span> <span class="title">AssignerWithPunctuatedWatermarks</span>&lt;<span class="title">MyElement</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(MyElement element, <span class="keyword">long</span> previousElementTimestamp)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> element.getSequenceTimestamp();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Watermark <span class="title">checkAndGetNextWatermark</span><span class="params">(MyElement lastElement, <span class="keyword">long</span> extractedTimestamp)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> lastElement.isEndOfSequence() ? <span class="keyword">new</span> Watermark(extractedTimestamp) : <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>我们平常用的最多的还是<code>AssignerWithPeriodicWatermarks</code> 并设置数据到达最大超时时长。下面的分析我们就以<code>AssignerWithPeriodicWatermarks</code>为例。<br>想到一个点<code>AssignerWithPunctuatedWatermarks</code>的一个使用场景:可能比较适合于数据不是连续发送或者说是批任务的场景，比如说是每天某时候数据有更新之后才有计算，那么只要在进入的最后一个数据打入endFlag，然后进行waterMark更新触发数据处理（一个想法，尚未实践）。</p>
<h3 id="waterMark在传输及对window-Operator的作用方式"><a href="#waterMark在传输及对window-Operator的作用方式" class="headerlink" title="waterMark在传输及对window Operator的作用方式"></a>waterMark在传输及对window Operator的作用方式</h3><h4 id="TimestampsAndPeriodicWatermarksOperator"><a href="#TimestampsAndPeriodicWatermarksOperator" class="headerlink" title="TimestampsAndPeriodicWatermarksOperator"></a>TimestampsAndPeriodicWatermarksOperator</h4><p>在DataStream调用<code>assignTimestampsAndWatermarks</code>产生了一个<code>TimestampsAndPeriodicWatermarksOperator</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> SingleOutputStreamOperator&lt;T&gt; <span class="title">assignTimestampsAndWatermarks</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	AssignerWithPeriodicWatermarks&lt;T&gt; timestampAndWatermarkAssigner)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// match parallelism to input, otherwise dop=1 sources could lead to some strange</span></span><br><span class="line">	<span class="comment">// behaviour: the watermark will creep along very slowly because the elements</span></span><br><span class="line">	<span class="comment">// from the source go to each extraction operator round robin.</span></span><br><span class="line">	<span class="comment">//这里就是说一般会默认将并发度设成和inputOperator的并发度一致，避免因为elements进入extraction operator的时候要随机进入分区。</span></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> inputParallelism = getTransformation().getParallelism();</span><br><span class="line">	<span class="keyword">final</span> AssignerWithPeriodicWatermarks&lt;T&gt; cleanedAssigner = clean(timestampAndWatermarkAssigner);</span><br><span class="line">		</span><br><span class="line">	TimestampsAndPeriodicWatermarksOperator&lt;T&gt; operator = </span><br><span class="line">			<span class="keyword">new</span> TimestampsAndPeriodicWatermarksOperator&lt;&gt;(cleanedAssigner);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> transform(<span class="string">"Timestamps/Watermarks"</span>, getTransformation().getOutputType(), operator)</span><br><span class="line">			.setParallelism(inputParallelism);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看这个<code>TimestampsAndPeriodicWatermarksOperator</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.open();</span><br><span class="line"></span><br><span class="line">	currentWatermark = Long.MIN_VALUE;</span><br><span class="line">	watermarkInterval = getExecutionConfig().getAutoWatermarkInterval();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (watermarkInterval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">long</span> now = getProcessingTimeService().getCurrentProcessingTime();</span><br><span class="line">		getProcessingTimeService().registerTimer(now + watermarkInterval, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProcessingTime</span><span class="params">(<span class="keyword">long</span> timestamp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// register next timer</span></span><br><span class="line">	Watermark newWatermark = userFunction.getCurrentWatermark();</span><br><span class="line">	<span class="keyword">if</span> (newWatermark != <span class="keyword">null</span> &amp;&amp; newWatermark.getTimestamp() &gt; currentWatermark) &#123;</span><br><span class="line">		currentWatermark = newWatermark.getTimestamp();</span><br><span class="line">		<span class="comment">// emit watermark</span></span><br><span class="line">		output.emitWatermark(newWatermark);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> now = getProcessingTimeService().getCurrentProcessingTime();</span><br><span class="line">	getProcessingTimeService().registerTimer(now + watermarkInterval, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这两个方法，会从TimestampsAndPeriodicWatermarksOperator定期<code>watermarkInterval</code>发送<code>userFunction.getCurrentWatermark()</code>用户定义的waterMark,当然也是要waterMark有上涨的情况下才会发送</p>
<p>而且这里有个有意思的地方,这里也定义了<code>processWatermark</code>方法，该方法主要调用时机主要，是在<code>StreamInputProcessor#processInput</code>中,这个类在后面再具体分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processWatermark</span><span class="params">(Watermark mark)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// if we receive a Long.MAX_VALUE watermark we forward it since it is used</span></span><br><span class="line">	<span class="comment">// to signal the end of input and to not block watermark progress downstream</span></span><br><span class="line">	<span class="keyword">if</span> (mark.getTimestamp() == Long.MAX_VALUE &amp;&amp; currentWatermark != Long.MAX_VALUE) &#123;</span><br><span class="line">		currentWatermark = Long.MAX_VALUE;</span><br><span class="line">		output.emitWatermark(mark);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这里覆盖了<code>AbstractStreamOperator</code>中的写法是为什么呢?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processWatermark</span><span class="params">(Watermark mark)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (HeapInternalTimerService&lt;?, ?&gt; service : timerServices.values()) &#123;</span><br><span class="line">		service.advanceWatermark(mark.getTimestamp());</span><br><span class="line">	&#125;</span><br><span class="line">	output.emitWatermark(mark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实体现了在最后一个<code>TimestampsAndPeriodicWatermarksOperator</code>之前定义的waterMark传递此operator的时候除非是一个流结束标志<code>Long.MAX_VALUE</code>,否则不会发送，只会有该operator定时发送waterMark给下游处理，这也就说明了在source处定义的waterMark会被后面定义的给覆盖。</p>
<p>所以大部分Operator处理waterMark的方式是<code>AbstractStreamOperator</code>中定义好的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processWatermark</span><span class="params">(Watermark mark)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (HeapInternalTimerService&lt;?, ?&gt; service : timerServices.values()) &#123;</span><br><span class="line">		service.advanceWatermark(mark.getTimestamp());<span class="comment">//这个处理逻辑还要在看下</span></span><br><span class="line">	&#125;</span><br><span class="line">	output.emitWatermark(mark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里看到他是会给所有的下游channel发送一个watermark</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emitWatermark</span><span class="params">(Watermark mark)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (Output&lt;StreamRecord&lt;OUT&gt;&gt; out : allOutputs) &#123;</span><br><span class="line">		out.emitWatermark(mark);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="StreamInputProcessor"><a href="#StreamInputProcessor" class="headerlink" title="StreamInputProcessor"></a>StreamInputProcessor</h4><p>processWatermark是在<code>StreamInputprocessor</code>中调用的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (recordOrMark.isWatermark()) &#123;</span><br><span class="line">		<span class="keyword">long</span> watermarkMillis = recordOrMark.asWatermark().getTimestamp();</span><br><span class="line">		<span class="keyword">if</span> (watermarkMillis &gt; watermarks[currentChannel]) &#123;</span><br><span class="line">			watermarks[currentChannel] = watermarkMillis;</span><br><span class="line">			<span class="keyword">long</span> newMinWatermark = Long.MAX_VALUE;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">long</span> watermark: watermarks) &#123;</span><br><span class="line">				newMinWatermark = Math.min(watermark, newMinWatermark);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (newMinWatermark &gt; lastEmittedWatermark) &#123;</span><br><span class="line">				lastEmittedWatermark = newMinWatermark;</span><br><span class="line">				<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">					streamOperator.processWatermark(<span class="keyword">new</span> Watermark(lastEmittedWatermark));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑总结:（channel的理解还不够）</p>
<ol>
<li>如果消费到的消息是一个 WaterMark，获得其对应的 source channel id 并将时间更新进去，同时记录下当前所有 channel 的最小 WaterMark 时间</li>
<li>如果当前最小 WaterMark 时间【所有的 channel 都至少消费到该时间】大于上次发射给下游的 WaterMark 时间，则更新 WaterMark 时间并将其交给算子处理</li>
<li>通常算子在处理【尤其是涉及了窗口计算或者需要时间缓存策略的算子】后会将 WaterMark 继续往下游广播发送</li>
</ol>
<h3 id="waterMark对window作用形式"><a href="#waterMark对window作用形式" class="headerlink" title="waterMark对window作用形式"></a>waterMark对window作用形式</h3><p>waterMark如何触发窗口计算</p>
<h4 id="情况一-late-element"><a href="#情况一-late-element" class="headerlink" title="情况一: late element"></a>情况一: late element</h4><ul>
<li>Event Time &lt; watermark时间（对于late element太多的数据而言）,这种情况下只要来一条数据就会触发窗口计算，其他属于该窗口的数据到达后都会被丢弃。</li>
</ul>
<h4 id="情况二：乱序"><a href="#情况二：乱序" class="headerlink" title="情况二：乱序"></a>情况二：乱序</h4><ul>
<li>watermark时间 &gt;= window_end_time（对于out-of-order以及正常的数据而言）</li>
<li>在[window_start_time,window_end_time)中有数据存在</li>
</ul>
<p>window的触发机制，是先按照自然时间将window划分，如果window大小是3秒，那么1分钟内会把window划分为如下的形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[00:00:00,00:00:03)</span><br><span class="line">[00:00:03,00:00:06)</span><br><span class="line">...</span><br><span class="line">[00:00:57,00:01:00)</span><br></pre></td></tr></table></figure>
<p>如果window大小是10秒，则window会被分为如下的形式：当然还有一个offset值可以控制window的起始值不是整点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[00:00:00,00:00:10)</span><br><span class="line">[00:00:10,00:00:20)</span><br><span class="line">...</span><br><span class="line">[00:00:50,00:01:00)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onElement</span><span class="params">(Object element, <span class="keyword">long</span> timestamp, TimeWindow window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (window.maxTimestamp() &lt;= ctx.getCurrentWatermark()) &#123;</span><br><span class="line">		<span class="comment">// if the watermark is already past the window fire immediately</span></span><br><span class="line">		<span class="keyword">return</span> TriggerResult.FIRE;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ctx.registerEventTimeTimer(window.maxTimestamp());</span><br><span class="line">		<span class="keyword">return</span> TriggerResult.CONTINUE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>EventTimeTrigger</code>中当<code>ctx.getCurrentWatermark &gt; window.maxTimestamp</code>时立刻触发窗口计算.</p>
<p>当然没有内容是不会触发计算的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (triggerResult.isFire()) &#123;</span><br><span class="line">					ACC contents = windowState.get();</span><br><span class="line">					<span class="keyword">if</span> (contents == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					emitWindowContents(actualWindow, contents);</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>
<p>输入的数据中，根据自身的Event Time，将数据划分到不同的window中，如果window中有数据，则当watermark时间&gt;=window_edn_time时，就符合了window触发的条件了，最终决定window触发，还是由数据本身的Event Time所属的window中的window_end_time决定。</p>
<p>以上代码和情况二相符，其实情况一也是情况二的特殊情况，watermark &gt; 数据的 eventtime也就是说超过了最大的延迟时间，此时其实也是来了之后watermark &gt; window.endtime，然后必然会被触发只是其他该窗格的数据会被丢弃罢了。</p>
<p>数据清理的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isLate</span><span class="params">(W window)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (windowAssigner.isEventTime() &amp;&amp; (cleanupTime(window) &lt;= internalTimerService.currentWatermark()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">cleanupTime</span><span class="params">(W window)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (windowAssigner.isEventTime()) &#123;</span><br><span class="line">			<span class="keyword">long</span> cleanupTime = window.maxTimestamp() + allowedLateness;</span><br><span class="line">			<span class="keyword">return</span> cleanupTime &gt;= window.maxTimestamp() ? cleanupTime : Long.MAX_VALUE;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> window.maxTimestamp();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>最大乱序时间要结合自己的业务以及数据情况去设置。如果maxOutOfOrderness设置的太小，而自身数据发送时由于网络等原因导致乱序或者late太多，那么最终的结果就是会有很多单条的数据在window中被触发，数据的正确性影响太大，对此可以通过在windowOperator处添加metrics监控来指导业务方设置成什么样的一个值才是最合理的。</p>
<h4 id="allowLatency"><a href="#allowLatency" class="headerlink" title="allowLatency"></a>allowLatency</h4><p>最后一点上文代码里提到的这个allowLatency又有什么作用呢?</p>
<p>默认情况下当watermark涨过了window的endtime之后，再有属于该窗口的数据到来的时候该数据会被丢弃，设置了allowLatency这个值之后，也就是定义了数据在watermark涨过window.endtime但是又在allowlatency之前到达的话仍旧会被加到对应的窗口去。会使得窗口<strong>再次</strong>被触发。Flink会保存窗口的状态直到allow latenness 超期。</p>
<p>待补充：</p>
<ol>
<li>对流传输过程中channel的理解</li>
<li>keyby操作过程对watermark的影响 </li>
<li>advanceWatermark操作理解</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/lmalds/article/details/52704170" target="_blank" rel="noopener">http://blog.csdn.net/lmalds/article/details/52704170</a><br><a href="http://chenyuzhao.me/2017/02/09/flink-watermark-checkpoint/" target="_blank" rel="noopener">http://chenyuzhao.me/2017/02/09/flink-watermark-checkpoint/</a><br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/dev/event_timestamps_watermarks.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.2/dev/event_timestamps_watermarks.html</a><br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/dev/windows.html#allowed-lateness" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.2/dev/windows.html#allowed-lateness</a></p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>谢谢支持</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="aitozi WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Flink/" rel="tag"># Flink</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/flink-latency-tracker.html" rel="next" title="flink-latency-tracker">
                <i class="fa fa-chevron-left"></i> flink-latency-tracker
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/arraydequeue-source-code.html" rel="prev" title="ArrayDeque源码分析">
                ArrayDeque源码分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="aitozi">
          <p class="site-author-name" itemprop="name">aitozi</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="gjying1314@gmail.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://wuchong.me/" title="wuchong" target="_blank">wuchong</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://chenyuzhao.me/" title="yuzhao" target="_blank">yuzhao</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/yanghua_kobe?viewmode=contents" title="vinoyang" target="_blank">vinoyang</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/lmalds?viewmode=contents" title="Imalds" target="_blank">Imalds</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/androidlushangderen" title="hadoop" target="_blank">hadoop</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.cnblogs.com/xrq730/p/5260294.html" title="java开发" target="_blank">java开发</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.hollischuang.com/" title="阿里工程师" target="_blank">阿里工程师</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.cnblogs.com/fxjwind/" title="阿里流计算工程师" target="_blank">阿里流计算工程师</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://jm.taobao.org/" title="阿里中间件博客" target="_blank">阿里中间件博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://armsword.com/" title="duruofei" target="_blank">duruofei</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.yufeng.info/" title="褚霸" target="_blank">褚霸</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://yuzhouwan.com" title="宇宙湾" target="_blank">宇宙湾</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://matt33.com" title="matt" target="_blank">matt</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://coding-geek.com/" title="coding-geek" target="_blank">coding-geek</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间语义"><span class="nav-number">2.</span> <span class="nav-text">时间语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#waterMark产生方式"><span class="nav-number">3.</span> <span class="nav-text">waterMark产生方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法一-在数据源处产生发送"><span class="nav-number">3.1.</span> <span class="nav-text">方法一 在数据源处产生发送</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法二-使用TimestampAssigner来实现"><span class="nav-number">3.2.</span> <span class="nav-text">方法二 使用TimestampAssigner来实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AssignerWithPeriodicWatermarks"><span class="nav-number">3.2.1.</span> <span class="nav-text">AssignerWithPeriodicWatermarks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AssignerWithPunctuatedWatermarks"><span class="nav-number">3.2.2.</span> <span class="nav-text">AssignerWithPunctuatedWatermarks</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小结"><span class="nav-number">3.2.3.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#waterMark在传输及对window-Operator的作用方式"><span class="nav-number">4.</span> <span class="nav-text">waterMark在传输及对window Operator的作用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TimestampsAndPeriodicWatermarksOperator"><span class="nav-number">4.1.</span> <span class="nav-text">TimestampsAndPeriodicWatermarksOperator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StreamInputProcessor"><span class="nav-number">4.2.</span> <span class="nav-text">StreamInputProcessor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#waterMark对window作用形式"><span class="nav-number">5.</span> <span class="nav-text">waterMark对window作用形式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#情况一-late-element"><span class="nav-number">5.1.</span> <span class="nav-text">情况一: late element</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#情况二：乱序"><span class="nav-number">5.2.</span> <span class="nav-text">情况二：乱序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结-1"><span class="nav-number">5.3.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#allowLatency"><span class="nav-number">5.4.</span> <span class="nav-text">allowLatency</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aitozi</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://aitozi.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.aitozi.com/flink-watermark.html';
          this.page.identifier = 'flink-watermark.html';
          this.page.title = 'flink-watermark';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://aitozi.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  








  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
</html>
