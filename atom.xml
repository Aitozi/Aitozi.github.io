<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aitozi</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="yoursite.com/"/>
  <updated>2018-03-11T14:39:45.000Z</updated>
  <id>yoursite.com/</id>
  
  <author>
    <name>aitozi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>上篇·flink 1.4利用kafka0.11实现完整的一致性语义</title>
    <link href="yoursite.com/2018/03/11/flink-kafka-exactly-once/"/>
    <id>yoursite.com/2018/03/11/flink-kafka-exactly-once/</id>
    <published>2018-03-11T14:29:44.000Z</published>
    <updated>2018-03-11T14:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>flink kafka-connector0.10版本分析，与1.4版本中kafka11对比</p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>官方文档在出了1.4之后特意发表了一篇blog，通过以下这两个条件实现了真正意义上的exactly once语义</p>
<ol>
<li>kafka producer0.11的事务性</li>
<li><a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol" target="_blank" rel="external">two phase commit protocol</a></li>
</ol>
<p>我们先看0.10版本的kafka-connector的行为逻辑.</p>
<h1 id="Kafka-Connector10"><a href="#Kafka-Connector10" class="headerlink" title="Kafka-Connector10"></a>Kafka-Connector10</h1><h2 id="kafkaConsumer10"><a href="#kafkaConsumer10" class="headerlink" title="kafkaConsumer10"></a>kafkaConsumer10</h2><h3 id="FlinkKafkaConsumerBase"><a href="#FlinkKafkaConsumerBase" class="headerlink" title="FlinkKafkaConsumerBase"></a>FlinkKafkaConsumerBase</h3><p>这个抽象类实现了<code>CheckpointedFunction</code>, 这个接口的描述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* This is the core <span class="class"><span class="keyword">interface</span> <span class="title">for</span> &lt;<span class="title">i</span>&gt;<span class="title">stateful</span> <span class="title">transformation</span> <span class="title">functions</span>&lt;/<span class="title">i</span>&gt;, <span class="title">meaning</span> <span class="title">functions</span></span></div><div class="line">* <span class="title">that</span> <span class="title">maintain</span> <span class="title">state</span> <span class="title">across</span> <span class="title">individual</span> <span class="title">stream</span> <span class="title">records</span>.</div><div class="line">* <span class="title">While</span> <span class="title">more</span> <span class="title">lightweight</span> <span class="title">interfaces</span> <span class="title">exist</span> <span class="title">as</span> <span class="title">shortcuts</span> <span class="title">for</span> <span class="title">various</span> <span class="title">types</span> <span class="title">of</span> <span class="title">state</span>, <span class="title">this</span> <span class="title">interface</span> <span class="title">offer</span> <span class="title">the</span></div><div class="line">* <span class="title">greatest</span> <span class="title">flexibility</span> <span class="title">in</span> <span class="title">managing</span> <span class="title">both</span> &lt;<span class="title">i</span>&gt;<span class="title">keyed</span> <span class="title">state</span>&lt;/<span class="title">i</span>&gt; <span class="title">and</span> &lt;<span class="title">i</span>&gt;<span class="title">operator</span> <span class="title">state</span>&lt;/<span class="title">i</span>&gt;.</div></pre></td></tr></table></figure>
<p>这个接口中主要要去做两件事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//每一次做checkpoint的时候被调用</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line"><span class="comment">//初始化每一个并发的实例的时候被调用</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span> Exception</span>;</div></pre></td></tr></table></figure>
<p>初始化函数的调用时机是在<code>open</code>之前的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//StreamTask.java</span></div><div class="line">initializeState();</div><div class="line">openAllOperators();</div></pre></td></tr></table></figure>
<p>在初始化的函数中提供了一个<code>FunctionSnapshotContext</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void snapshotState(FunctionSnapshotContext context) throws Exception;</div></pre></td></tr></table></figure></p>
<p>让你既可以注册一个KeyedStateStore，也可以注册一个OperatorStateStore</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ManagedInitializationContext</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Returns true, if state was restored from the snapshot of a previous execution. This returns always false for</div><div class="line">	 * stateless tasks.</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isRestored</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Returns an interface that allows for registering operator state with the backend.</div><div class="line">	 */</div><div class="line">	<span class="function">OperatorStateStore <span class="title">getOperatorStateStore</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Returns an interface that allows for registering keyed state with the backend.</div><div class="line">	 */</div><div class="line">	<span class="function">KeyedStateStore <span class="title">getKeyedStateStore</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到kafka10是怎么利用这个<code>CheckpointedFunction</code>来管理记录内部offset的呢？  </p>
<h3 id="initializeState"><a href="#initializeState" class="headerlink" title="initializeState"></a>initializeState</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化过程</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">// we might have been restored via restoreState() which restores from legacy operator state</span></div><div class="line">		<span class="keyword">if</span> (!restored) &#123;</div><div class="line">			restored = context.isRestored();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		OperatorStateStore stateStore = context.getOperatorStateStore();</div><div class="line">		offsetsStateForCheckpoint = stateStore.getSerializableListState(DefaultOperatorStateBackend.DEFAULT_OPERATOR_STATE_NAME);</div><div class="line">		<span class="comment">//如果是在重启恢复的过程中</span></div><div class="line">		<span class="keyword">if</span> (context.isRestored()) &#123;</div><div class="line">			<span class="keyword">if</span> (restoredState == <span class="keyword">null</span>) &#123;</div><div class="line">				restoredState = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">				<span class="keyword">for</span> (Tuple2&lt;KafkaTopicPartition, Long&gt; kafkaOffset : offsetsStateForCheckpoint.get()) &#123;</div><div class="line">				<span class="comment">//partition和相应的offset数</span></div><div class="line">					restoredState.put(kafkaOffset.f0, kafkaOffset.f1);</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				LOG.info(<span class="string">"Setting restore state in the FlinkKafkaConsumer."</span>);</div><div class="line">				<span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">					LOG.debug(<span class="string">"Using the following offsets: &#123;&#125;"</span>, restoredState);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			LOG.info(<span class="string">"No restore state for FlinkKafkaConsumer."</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>那么我们看到恢复或者初始化的时候将<partition,offset>信息保存到了一组HashMap中，但是这个Map怎么作用于消费阶段呢？</partition,offset></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将从状态中获取到的列表赋予给消费的列表</span></div><div class="line">subscribedPartitionsToStartOffsets = restoredState;</div></pre></td></tr></table></figure>
<h3 id="snapshot"><a href="#snapshot" class="headerlink" title="snapshot"></a>snapshot</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="keyword">if</span> (!running) &#123;</div><div class="line">		LOG.debug(<span class="string">"snapshotState() called on closed source"</span>);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">		offsetsStateForCheckpoint.clear();</div><div class="line"></div><div class="line">		<span class="keyword">final</span> AbstractFetcher&lt;?, ?&gt; fetcher = <span class="keyword">this</span>.kafkaFetcher;</div><div class="line">		<span class="keyword">if</span> (fetcher == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="comment">// fetcher还没有初始化，返回上一次恢复的partition和offset，也就是这里会有个bug。我提了个issue:[FLINK-8869][2]</span></div><div class="line">			<span class="keyword">for</span> (Map.Entry&lt;KafkaTopicPartition, Long&gt; subscribedPartition : subscribedPartitionsToStartOffsets.entrySet()) &#123;</div><div class="line">				offsetsStateForCheckpoint.add(Tuple2.of(subscribedPartition.getKey(), subscribedPartition.getValue()));</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//</span></div><div class="line">			<span class="keyword">if</span> (offsetCommitMode == OffsetCommitMode.ON_CHECKPOINTS) &#123;</div><div class="line">				<span class="comment">// the map cannot be asynchronously updated, because only one checkpoint call can happen</span></div><div class="line">				<span class="comment">// on this function at a time: either snapshotState() or notifyCheckpointComplete()</span></div><div class="line">				pendingOffsetsToCommit.put(context.getCheckpointId(), restoredState);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			HashMap&lt;KafkaTopicPartition, Long&gt; currentOffsets = fetcher.snapshotCurrentState();</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (offsetCommitMode == OffsetCommitMode.ON_CHECKPOINTS) &#123;</div><div class="line">				<span class="comment">// the map cannot be asynchronously updated, because only one checkpoint call can happen</span></div><div class="line">				<span class="comment">// on this function at a time: either snapshotState() or notifyCheckpointComplete()</span></div><div class="line">				pendingOffsetsToCommit.put(context.getCheckpointId(), currentOffsets);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">for</span> (Map.Entry&lt;KafkaTopicPartition, Long&gt; kafkaTopicPartitionLongEntry : currentOffsets.entrySet()) &#123;</div><div class="line">				offsetsStateForCheckpoint.add(</div><div class="line">						Tuple2.of(kafkaTopicPartitionLongEntry.getKey(), kafkaTopicPartitionLongEntry.getValue()));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (offsetCommitMode == OffsetCommitMode.ON_CHECKPOINTS) &#123;</div><div class="line">			<span class="comment">// truncate the map of pending offsets to commit, to prevent infinite growth</span></div><div class="line">			<span class="keyword">while</span> (pendingOffsetsToCommit.size() &gt; MAX_NUM_PENDING_CHECKPOINTS) &#123;</div><div class="line">				pendingOffsetsToCommit.remove(<span class="number">0</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="offsetCommitMode"><a href="#offsetCommitMode" class="headerlink" title="offsetCommitMode"></a>offsetCommitMode</h3><p>如上述代码中的<code>offsetCommitMode</code>,主要有以下几种</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DISABLED,</div><div class="line">ON_CHECKPOINTS, <span class="comment">// 完成一次checkpoint后向kafka提交消费offset，只有这种模式下才需要我们手动去提交offset到kafka</span></div><div class="line">KAFKA_PERIODIC;</div></pre></td></tr></table></figure>
<p>这个配置主要改变了commitOffset回kafka的时机. 首先在snapshot的时候会将对应的checkpointId和相应的offset的列表放入<code>pendingOffsetsToCommit</code>, 在checkpoint完成后回调<code>notifyCheckpointComplete</code>，这里面主要完成了offset的commit工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (offsetCommitMode == OffsetCommitMode.ON_CHECKPOINTS) &#123;</div><div class="line">			<span class="comment">// only one commit operation must be in progress</span></div><div class="line">			<span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</div><div class="line">				LOG.debug(<span class="string">"Committing offsets to Kafka/ZooKeeper for checkpoint "</span> + checkpointId);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">final</span> <span class="keyword">int</span> posInMap = pendingOffsetsToCommit.indexOf(checkpointId);</div><div class="line">				<span class="keyword">if</span> (posInMap == -<span class="number">1</span>) &#123;</div><div class="line">					LOG.warn(<span class="string">"Received confirmation for unknown checkpoint id &#123;&#125;"</span>, checkpointId);</div><div class="line">					<span class="keyword">return</span>;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">				HashMap&lt;KafkaTopicPartition, Long&gt; offsets =</div><div class="line">					(HashMap&lt;KafkaTopicPartition, Long&gt;) pendingOffsetsToCommit.remove(posInMap);</div><div class="line"></div><div class="line">				<span class="comment">// remove older checkpoints in map</span></div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; posInMap; i++) &#123;</div><div class="line">					pendingOffsetsToCommit.remove(<span class="number">0</span>);</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				<span class="keyword">if</span> (offsets == <span class="keyword">null</span> || offsets.size() == <span class="number">0</span>) &#123;</div><div class="line">					LOG.debug(<span class="string">"Checkpoint state was empty."</span>);</div><div class="line">					<span class="keyword">return</span>;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				fetcher.commitInternalOffsetsToKafka(offsets, offsetCommitCallback);</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">				<span class="keyword">if</span> (running) &#123;</div><div class="line">					<span class="keyword">throw</span> e;</div><div class="line">				&#125;</div><div class="line">				<span class="comment">// else ignore exception if we are no longer running</span></div><div class="line">			&#125;</div></pre></td></tr></table></figure>
<h3 id="消费partition分配问题"><a href="#消费partition分配问题" class="headerlink" title="消费partition分配问题"></a>消费partition分配问题</h3><ul>
<li><p>在从上次点恢复的情况下是直接从state中获取应该读取哪一个partition，offset。如果并发度改变了会做出什么样的反馈呢?会正确做出rescale吗</p>
</li>
<li><p>第一次进行读取的时候会初始化处当前task（并发度）所需要订阅的partition</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Map&lt;KafkaTopicPartition, Long&gt; <span class="title">initializeSubscribedPartitionsToStartOffsets</span><span class="params">(</span></span></div><div class="line">			List&lt;KafkaTopicPartition&gt; kafkaTopicPartitions, //topic的所有partition</div><div class="line">			<span class="keyword">int</span> indexOfThisSubtask, // 当前task的维度</div><div class="line">			<span class="keyword">int</span> numParallelSubtasks, // 总的并发度</div><div class="line">			StartupMode startupMode, // 从哪个offset消费的模式（最新，最老，指定offset）</div><div class="line">			Map&lt;KafkaTopicPartition, Long&gt; specificStartupOffsets) &#123;</div><div class="line"></div><div class="line">		Map&lt;KafkaTopicPartition, Long&gt; subscribedPartitionsToStartOffsets = <span class="keyword">new</span> HashMap&lt;&gt;(kafkaTopicPartitions.size());</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (KafkaTopicPartition kafkaTopicPartition : kafkaTopicPartitions) &#123;</div><div class="line">			<span class="comment">// only handle partitions that this subtask should subscribe to（选取当前subtask所需要订阅的partition）</span></div><div class="line">			<span class="keyword">if</span> (KafkaTopicPartitionAssigner.assign(kafkaTopicPartition, numParallelSubtasks) == indexOfThisSubtask) &#123;</div><div class="line">				<span class="keyword">if</span> (startupMode != StartupMode.SPECIFIC_OFFSETS) &#123;</div><div class="line">					<span class="comment">//StateSentinel都是一串随机的负数占位符(都是一个标记在KafkaConsumerThread中进行判断)</span></div><div class="line">					subscribedPartitionsToStartOffsets.put(kafkaTopicPartition, startupMode.getStateSentinel());</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					<span class="keyword">if</span> (specificStartupOffsets == <span class="keyword">null</span>) &#123;</div><div class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">							<span class="string">"Startup mode for the consumer set to "</span> + StartupMode.SPECIFIC_OFFSETS +</div><div class="line">								<span class="string">", but no specific offsets were specified"</span>);</div><div class="line">					&#125;</div><div class="line"></div><div class="line">					Long specificOffset = specificStartupOffsets.get(kafkaTopicPartition);</div><div class="line">					<span class="keyword">if</span> (specificOffset != <span class="keyword">null</span>) &#123;</div><div class="line">						<span class="comment">// since the specified offsets represent the next record to read, we subtract</span></div><div class="line">						<span class="comment">// it by one so that the initial state of the consumer will be correct</span></div><div class="line">						<span class="comment">// 这里需要减去1</span></div><div class="line">						subscribedPartitionsToStartOffsets.put(kafkaTopicPartition, specificOffset - <span class="number">1</span>);</div><div class="line">					&#125; <span class="keyword">else</span> &#123;</div><div class="line">						subscribedPartitionsToStartOffsets.put(kafkaTopicPartition, KafkaTopicPartitionStateSentinel.GROUP_OFFSET);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> subscribedPartitionsToStartOffsets;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">assign</span><span class="params">(KafkaTopicPartition partition, <span class="keyword">int</span> numParallelSubtasks)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> startIndex = ((partition.getTopic().hashCode() * <span class="number">31</span>) &amp; <span class="number">0x7FFFFFFF</span>) % numParallelSubtasks;</div><div class="line"></div><div class="line">	<span class="comment">// here, the assumption is that the id of Kafka partitions are always ascending</span></div><div class="line">	<span class="comment">// starting from 0, and therefore can be used directly as the offset clockwise from the start index</span></div><div class="line">	<span class="comment">// 这里看出：每个Partition只会分配到一个subtask来消费</span></div><div class="line">	<span class="comment">// 1. partition &gt; parallel 一个subtask会订阅多个partition</span></div><div class="line">	<span class="comment">// 2. partition &lt; parallel 有subtask会是空闲的</span></div><div class="line">	<span class="comment">// 3. startIndex由topic名字计算得出</span></div><div class="line">	<span class="keyword">return</span> (startIndex + partition.getPartition()) % numParallelSubtasks;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="消费模型kafka10"><a href="#消费模型kafka10" class="headerlink" title="消费模型kafka10"></a>消费模型kafka10</h3><p>在完成partition订阅之后，就要开始真正的run方法了，<code>FlinkKafkaConsumer</code>也是实现自<code>SouceFunction</code>，因此主要的逻辑也都是在run方法中实现。 主要逻辑：</p>
<p>kafkaConsumerThread和Kafka10Fetcher通过<code>Handover</code>交互,我觉得这段代码写的很不错，可以好好学习下。可以形象的比作在接力跑：<code>kafkaConsumerThread</code>通过真正的消费线程消费放入一个<code>HandOver</code>，再由kafkaFetcher去poll，完成整个消费过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// we need only do work, if we actually have partitions assigned</span></div><div class="line"><span class="keyword">if</span> (!subscribedPartitionsToStartOffsets.isEmpty()) &#123;</div><div class="line"></div><div class="line">	<span class="comment">// create the fetcher that will communicate with the Kafka brokers</span></div><div class="line">	<span class="keyword">final</span> AbstractFetcher&lt;T, ?&gt; fetcher = createFetcher(</div><div class="line">			sourceContext,</div><div class="line">			subscribedPartitionsToStartOffsets,</div><div class="line">			periodicWatermarkAssigner,</div><div class="line">			punctuatedWatermarkAssigner,</div><div class="line">			(StreamingRuntimeContext) getRuntimeContext(),</div><div class="line">			offsetCommitMode);</div><div class="line"></div><div class="line">	<span class="comment">// publish the reference, for snapshot-, commit-, and cancel calls</span></div><div class="line">	<span class="comment">// IMPORTANT: We can only do that now, because only now will calls to</span></div><div class="line">	<span class="comment">//            the fetchers 'snapshotCurrentState()' method return at least</span></div><div class="line">	<span class="comment">//            the restored offsets</span></div><div class="line">	<span class="keyword">this</span>.kafkaFetcher = fetcher;</div><div class="line">	<span class="keyword">if</span> (!running) &#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// (3) run the fetcher' main work method</span></div><div class="line">	<span class="comment">// 主要工作方法</span></div><div class="line">	fetcher.runFetchLoop();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">	<span class="comment">// this source never completes, so emit a Long.MAX_VALUE watermark</span></div><div class="line">	<span class="comment">// to not block watermark forwarding</span></div><div class="line">	<span class="comment">// 发送最大的watermark就不会block住下游的watermark更新</span></div><div class="line">	sourceContext.emitWatermark(<span class="keyword">new</span> Watermark(Long.MAX_VALUE));</div><div class="line"></div><div class="line">	<span class="comment">// wait until this is canceled</span></div><div class="line">	<span class="keyword">final</span> Object waitLock = <span class="keyword">new</span> Object();</div><div class="line">	<span class="keyword">while</span> (running) &#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//noinspection SynchronizationOnLocalVariableOrMethodParameter</span></div><div class="line">			<span class="keyword">synchronized</span> (waitLock) &#123;</div><div class="line">				waitLock.wait();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			<span class="keyword">if</span> (!running) &#123;</div><div class="line">				<span class="comment">// restore the interrupted state, and fall through the loop</span></div><div class="line">				<span class="comment">// 打断当前线程</span></div><div class="line">				Thread.currentThread().interrupt();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Handover的描述， Handover代码可以再好好学习下。</div><div class="line">* The Handover is a utility to hand over data (a buffer of records) and exception from a</div><div class="line">* &lt;i&gt;producer&lt;/i&gt; thread to a &lt;i&gt;consumer&lt;/i&gt; thread. It effectively behaves like a</div><div class="line">* &quot;size one blocking queue&quot;, with some extras around exception reporting, closing, and</div><div class="line">* waking up thread without &#123;@link Thread#interrupt() interrupting&#125; threads.</div></pre></td></tr></table></figure>
<h3 id="KafkaFetcher"><a href="#KafkaFetcher" class="headerlink" title="KafkaFetcher"></a>KafkaFetcher</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runFetchLoop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">final</span> Handover handover = <span class="keyword">this</span>.handover;</div><div class="line"></div><div class="line">		<span class="comment">// kick off the actual Kafka consumer</span></div><div class="line">		<span class="comment">// 启动真正的消费线程</span></div><div class="line">		consumerThread.start();</div><div class="line"></div><div class="line">		<span class="keyword">while</span> (running) &#123;</div><div class="line">			<span class="comment">// this blocks until we get the next records</span></div><div class="line">			<span class="comment">// it automatically re-throws exceptions encountered in the fetcher thread</span></div><div class="line">			<span class="comment">// 在handover中获取真正的数据，并抛出其他线程中的异常</span></div><div class="line">			<span class="keyword">final</span> ConsumerRecords&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; records = handover.pollNext();</div><div class="line"></div><div class="line">			<span class="comment">// get the records for each topic partition</span></div><div class="line">			<span class="comment">// subscribedPartitionStates维护的是每个partition的状态（partition，KPH（partition的描述，依据版本可能不同），offset, committedOffset, watermark）</span></div><div class="line">			<span class="keyword">for</span> (KafkaTopicPartitionState&lt;TopicPartition&gt; partition : subscribedPartitionStates()) &#123;</div><div class="line"></div><div class="line">				List&lt;ConsumerRecord&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt; partitionRecords =</div><div class="line">						records.records(partition.getKafkaPartitionHandle());</div><div class="line"></div><div class="line">				<span class="keyword">for</span> (ConsumerRecord&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; record : partitionRecords) &#123;</div><div class="line">					<span class="keyword">final</span> T value = deserializer.deserialize(</div><div class="line">							record.key(), record.value(),</div><div class="line">							record.topic(), record.partition(), record.offset());</div><div class="line"></div><div class="line">					<span class="keyword">if</span> (deserializer.isEndOfStream(value)) &#123;</div><div class="line">						<span class="comment">// end of stream signaled</span></div><div class="line">						running = <span class="keyword">false</span>;</div><div class="line">						<span class="keyword">break</span>;</div><div class="line">					&#125;</div><div class="line"></div><div class="line">					<span class="comment">// emit the actual record. this also updates offset state atomically</span></div><div class="line">					<span class="comment">// and deals with timestamps and watermark generation</span></div><div class="line">					<span class="comment">// 这里会进入真正的通过sourceContext发送数据的代码 如下</span></div><div class="line">					emitRecord(value, partition, record.offset(), record);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">finally</span> &#123;</div><div class="line">		<span class="comment">// this signals the consumer thread that no more work is to be done</span></div><div class="line">		consumerThread.shutdown();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// on a clean exit, wait for the runner thread</span></div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		consumerThread.join();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">		<span class="comment">// may be the result of a wake-up interruption after an exception.</span></div><div class="line">		<span class="comment">// we ignore this here and only restore the interruption state</span></div><div class="line">		Thread.currentThread().interrupt();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">emitRecordWithTimestamp</span><span class="params">(</span></span></div><div class="line">		T record, KafkaTopicPartitionState&lt;KPH&gt; partitionState, <span class="keyword">long</span> offset, <span class="keyword">long</span> timestamp) <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (record != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (timestampWatermarkMode == NO_TIMESTAMPS_WATERMARKS) &#123;</div><div class="line">			<span class="comment">// fast path logic, in case there are no watermarks generated in the fetcher</span></div><div class="line"></div><div class="line">			<span class="comment">// emit the record, using the checkpoint lock to guarantee</span></div><div class="line">			<span class="comment">// atomicity of record emission and offset state update</span></div><div class="line">			<span class="keyword">synchronized</span> (checkpointLock) &#123;</div><div class="line">				sourceContext.collectWithTimestamp(record, timestamp);</div><div class="line">				partitionState.setOffset(offset);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (timestampWatermarkMode == PERIODIC_WATERMARKS) &#123;</div><div class="line">		    <span class="comment">// 更新partitionstate中的watermark状态</span></div><div class="line">			emitRecordWithTimestampAndPeriodicWatermark(record, partitionState, offset, timestamp);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			emitRecordWithTimestampAndPunctuatedWatermark(record, partitionState, offset, timestamp);</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// if the record is null, simply just update the offset state for partition</span></div><div class="line">		<span class="keyword">synchronized</span> (checkpointLock) &#123;</div><div class="line">			partitionState.setOffset(offset);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在设置了kafkaTimestampassigner之后就会进行一个定时任务向下游发送watermark，值为所有partition维护的最小值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProcessingTime</span><span class="params">(<span class="keyword">long</span> timestamp)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">long</span> minAcrossAll = Long.MAX_VALUE;</div><div class="line">	<span class="keyword">for</span> (KafkaTopicPartitionStateWithPeriodicWatermarks&lt;?, ?&gt; state : allPartitions) &#123;</div><div class="line">		</div><div class="line">		<span class="comment">// we access the current watermark for the periodic assigners under the state</span></div><div class="line">		<span class="comment">// lock, to prevent concurrent modification to any internal variables</span></div><div class="line">		<span class="keyword">final</span> <span class="keyword">long</span> curr;</div><div class="line">		<span class="comment">//noinspection SynchronizationOnLocalVariableOrMethodParameter</span></div><div class="line">		<span class="comment">// 这个锁是防止别的线程修改其他变量</span></div><div class="line">		<span class="keyword">synchronized</span> (state) &#123;</div><div class="line">			curr = state.getCurrentWatermarkTimestamp();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		minAcrossAll = Math.min(minAcrossAll, curr);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// emit next watermark, if there is one</span></div><div class="line">	<span class="keyword">if</span> (minAcrossAll &gt; lastWatermarkTimestamp) &#123;</div><div class="line">		lastWatermarkTimestamp = minAcrossAll;</div><div class="line">		emitter.emitWatermark(<span class="keyword">new</span> Watermark(minAcrossAll));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">// schedule the next watermark</span></div><div class="line">	timerService.registerTimer(timerService.getCurrentProcessingTime() + interval, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="KafkaConsumerThread"><a href="#KafkaConsumerThread" class="headerlink" title="KafkaConsumerThread"></a>KafkaConsumerThread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (records == <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					records = consumer.poll(pollTimeout);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">catch</span> (WakeupException we) &#123;</div><div class="line">					<span class="keyword">continue</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				handover.produce(records);</div><div class="line">				records = <span class="keyword">null</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">catch</span> (Handover.WakeupException e) &#123;</div><div class="line">				<span class="comment">// fall through the loop</span></div><div class="line">			&#125;</div></pre></td></tr></table></figure>
<p>主要做的工作就是从consumer消费数据塞入handover，等待拉取</p>
<h3 id="Handover"><a href="#Handover" class="headerlink" title="Handover"></a>Handover</h3><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerCallBridge</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assignPartitions</span><span class="params">(KafkaConsumer&lt;?, ?&gt; consumer, List&lt;TopicPartition&gt; topicPartitions)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		consumer.assign(topicPartitions);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seekPartitionToBeginning</span><span class="params">(KafkaConsumer&lt;?, ?&gt; consumer, TopicPartition partition)</span> </span>&#123;</div><div class="line">		consumer.seekToBeginning(partition);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seekPartitionToEnd</span><span class="params">(KafkaConsumer&lt;?, ?&gt; consumer, TopicPartition partition)</span> </span>&#123;</div><div class="line">		consumer.seekToEnd(partition);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解决08 09 10 版本的api不兼容问题</p>
<h2 id="Kafkaproducer10"><a href="#Kafkaproducer10" class="headerlink" title="Kafkaproducer10"></a>Kafkaproducer10</h2><p>###initializeState</p>
<p>什么都不做</p>
<h3 id="snapshot-1"><a href="#snapshot-1" class="headerlink" title="snapshot"></a>snapshot</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">snapshotState</span><span class="params">(FunctionSnapshotContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="comment">// check for asynchronous errors and fail the checkpoint if necessary</span></div><div class="line">	checkErroneous();</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (flushOnCheckpoint) &#123;</div><div class="line">		<span class="comment">// flushing is activated: We need to wait until pendingRecords is 0</span></div><div class="line">		flush();</div><div class="line">		<span class="keyword">synchronized</span> (pendingRecordsLock) &#123;</div><div class="line">			<span class="keyword">if</span> (pendingRecords != <span class="number">0</span>) &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Pending record count must be zero at this point: "</span> + pendingRecords);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// if the flushed requests has errors, we should propagate it also and fail the checkpoint</span></div><div class="line">			checkErroneous();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里涉及到一个flushOnCheckPoint的问题，再调用<code>producer.flush</code>期间，producer会将所有没写入的，在buffer中的数据刷盘，然后调用commitCallBack，这就保证了ckpt之后数据不会丢的问题。</p>
<p>主要工作方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(IN next)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="comment">// propagate asynchronous errors</span></div><div class="line">	checkErroneous();</div><div class="line"></div><div class="line">	<span class="keyword">byte</span>[] serializedKey = schema.serializeKey(next);</div><div class="line">	<span class="keyword">byte</span>[] serializedValue = schema.serializeValue(next);</div><div class="line">	<span class="comment">// 每条元素可以自己自己要写到的topic</span></div><div class="line">	String targetTopic = schema.getTargetTopic(next);</div><div class="line">	<span class="keyword">if</span> (targetTopic == <span class="keyword">null</span>) &#123;</div><div class="line">		targetTopic = defaultTopicId;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">int</span>[] partitions = <span class="keyword">this</span>.topicPartitionsMap.get(targetTopic);</div><div class="line">	<span class="keyword">if</span>(<span class="keyword">null</span> == partitions) &#123;</div><div class="line">		partitions = getPartitionsByTopic(targetTopic, producer);</div><div class="line">		<span class="keyword">this</span>.topicPartitionsMap.put(targetTopic, partitions);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ProducerRecord&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; record;</div><div class="line">	<span class="keyword">if</span> (flinkKafkaPartitioner == <span class="keyword">null</span>) &#123;</div><div class="line">		record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(targetTopic, serializedKey, serializedValue);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(</div><div class="line">				targetTopic,</div><div class="line">				flinkKafkaPartitioner.partition(next, serializedKey, serializedValue, targetTopic, partitions),</div><div class="line">				serializedKey,</div><div class="line">				serializedValue);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (flushOnCheckpoint) &#123;</div><div class="line">		<span class="keyword">synchronized</span> (pendingRecordsLock) &#123;</div><div class="line">			pendingRecords++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	producer.send(record, callback);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li><p>kafka恢复状态直接从状态中去获取了之前保存的partition和offset，但是如果是扩容partition的场景就不会从新的Partition消费 issue:<a href="https://issues.apache.org/jira/projects/FLINK/issues/FLINK-8869?filter=reportedbyme" target="_blank" rel="external">FLINK-8869</a></p>
</li>
<li><p>flink内部维护了offset，为什么向kafka提交的时候还需要在checkpoint之后再提交而不是定时提交就算了？</p>
<p> 因为虽然从checkpoint点恢复的时候不需要从kafka broker获取消费点的位置了，但是如果是应用重启消费上次消费到的点的数据，这个offset就是flink向kafka提交的，放在checkpoint完成后去做的好处就是让应用即使不是从上个点恢复的，也能够从kafka消费正确的offset点。</p>
</li>
<li><p>如果在新的checkpoint没打之前任务失败了，重新从上次的offset点消费的话下游数据是不是重复了?</p>
<p> <strong>是的，因为有一部分数据经过处理已经sink出去了，因此才需要0.11的一致性语义</strong></p>
</li>
</ol>
<p><em>以上代码：<br>kafka-connector0.10 来源于release1.3.2<br>kafka-connector0.11 来源于release1.4.0</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;flink kafka-connector0.10版本分析，与1.4版本中kafka11对比&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Flink" scheme="yoursite.com/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>flink-cep-paper</title>
    <link href="yoursite.com/2018/02/25/flink-cep-paper/"/>
    <id>yoursite.com/2018/02/25/flink-cep-paper/</id>
    <published>2018-02-25T12:19:15.000Z</published>
    <updated>2018-02-25T12:44:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>CEP实现论文</p>
<a id="more"></a>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>2016年1月29号，社区提了这个patch<a href="https://github.com/apache/flink/pull/1557" target="_blank" rel="external">[FLINK-3216]</a>引入flink cep模块，flink cep实现基于论文：<a href="https://people.cs.umass.edu/%7Eyanlei/publications/sase-sigmod08.pdf" target="_blank" rel="external">Efficient Pattern Matching over Event Streams</a>。我们来深入阅读以下这篇论文。</p>
<h3 id="event-pattern查询表达形式"><a href="#event-pattern查询表达形式" class="headerlink" title="event pattern查询表达形式"></a>event pattern查询表达形式</h3><p>先看三个查询<br><img src="http://or0igopk2.bkt.clouddn.com/18-2-25/25532292.jpg" alt=""></p>
<p><em>Query1</em></p>
<p>匹配出的是：挑选从货架取出的商品，未经checkout，带离了商店的行为序列</p>
<ol>
<li><code>SEQ(Shelf a, ∼(Register b), Exit c)</code></li>
<li>where条件指定了a，b，c的tagid相同</li>
<li>within指定窗口大小12小时</li>
</ol>
<p><em>Query2</em></p>
<p>匹配出的是：一个污染报警和相关受污染的发货卸货流转站点序列</p>
<ol>
<li>报警类型是污染</li>
<li>匹配出的装载点和前一个到达点一致</li>
<li>within指定匹配窗口大小是3小时</li>
</ol>
<p><em>Query3</em></p>
<p>匹配出的是：匹配股票交易拐点</p>
<ol>
<li>初始成交量高于1000</li>
<li>持续增加，最后成交量突然跌为最高点的80%以下的序列</li>
<li>1小时的时间窗口</li>
</ol>
<p>可以看出规则是怎么描述的：</p>
<ol>
<li>指定匹配出的序列是什么（structure）</li>
<li>限制或筛选条件 </li>
</ol>
<p>还需要匹配策略来进行规制匹配。</p>
<ol>
<li>严格的邻近匹配（Strict  contiguity）：只有连续两个event能满足匹配，中间不能夹杂其他不符合条件的元素</li>
<li>分区邻近匹配（Partition contiguity）：这就是说被选出的两个event之间不一定需要完全紧密相连，但是在一个分区中的需要紧密相连 如<em>Query3</em>中的a[]需要连续，a与b不需要连续</li>
<li>skip_till_next_match: 所有的不相关的元素都会被跳过，不再考虑是不是邻近的元素</li>
<li>skip_till_any_match: <em>Query2</em>解释了这种用法。比如当前最后识别的shipment到达了X位置。这时候读进来一条，X-&gt;Y的Event，在<code>skip_till_any_match</code>匹配规则下系统会做两件事：1.接收X-&gt;Y事件，更新状态2.在当前状态的另一个实例中不接收他来保留一个状态。这样当下一个比如来了个X-&gt;Z事件那还是可以接受这个实例。这种策略就是返回所有的可能的序列（allowing non-deterministic actions）在接收到同一个事件后可以有不一样的走向</li>
</ol>
<hr>
<p>以上介绍了event pattern的查询形式，接下来我们看其内部实现算法。</p>
<h3 id="NFA-非确定性自动状态机"><a href="#NFA-非确定性自动状态机" class="headerlink" title="NFA 非确定性自动状态机"></a>NFA 非确定性自动状态机</h3><p>非确定性自动状态机由以下结构组成。A = (Q,E,θ,q1,F),</p>
<pre><code>Q: 一系列状态
E： 边
θ： 计算公式
q1：起始状态
F: 结束状态
</code></pre><p><img src="http://or0igopk2.bkt.clouddn.com/18-2-25/18248041.jpg" alt=""></p>
<p><strong>States</strong></p>
<blockquote>
<p>the start state,a[1], is where the matching process begins.  It awaits input to start the Kleene plus and to select an event into the a[1] unit of the match<br>buffer.  At the next state a[i], it attempts to select another event into the a[i] (i &gt; 1) unit of the buffer.  The subsequent state b denotes that the matching process has fulfilled the Kleene plus (for a particular match) and is ready to process the next pattern component.  The final state, F, represents<br>the completion of the process, resulting in the creation of a pattern match.</p>
</blockquote>
<p><strong>Edges</strong></p>
<blockquote>
<p>Each state is associated with a number of edges,<br>representing the actions that can be taken at the state.  As Figure 2(a) shows, each state that is a singleton state or the first  state,p[1],  of  a pair  has  a  forward begin  edge.   Each second state, p[i], of a pair has a forward proceed edge, and a looping take edge.  Every state (except the start and final states)  has  a  looping ignore  edge.   The  start  state  has  no edges to it as we are only interested in matches that start with selected events.<br>Each edge at a state, q, is precisely described by a triplet:(1) a formula that specifies the condition on taking it, denoted by θq-edge, (2) an operation on the input stream (i.e.,consume an event or not), and (3) an operation on the match buffer (i.e.,  write to the buffer or not).  Formulas of edges are compiled from pattern queries, which we explain in detail shortly.  As shown in Figure 2(a), we use solid lines to denote begin and take edges that consume an event from the input and write it to the buffer, and dashed  lines for ignore edges that consume an event but do not write it to the  buffer. The  proceed  edge  is  a special edge: it does not consume any input event but only evaluates its formula and tries proceeding.  We distinguish the proceed edge from ignore edges in the style of arrow, denoting its behavior.</p>
</blockquote>
<p><em>非确定性</em><br>某些state具有两条边，但是这两条边的行为不一定是完全相反的</p>
<p>NFA算法过程：</p>
<ol>
<li>先根据整个structure构建state和边的行为</li>
<li>将condition翻译成边上的公式</li>
<li>将select strategy翻译成边上的公式</li>
<li>将时间窗口翻译成：最先匹配的元素和最后的元素时长不能超过窗口大小</li>
</ol>
<p>优化：</p>
<ol>
<li>先做过滤</li>
<li>将window条件前置</li>
<li>优化proceed边，进入下一个state的时候要检查是否满足begin的条件判断</li>
</ol>
<h3 id="带版本的内存共享"><a href="#带版本的内存共享" class="headerlink" title="带版本的内存共享"></a>带版本的内存共享</h3><p><img src="http://or0igopk2.bkt.clouddn.com/18-2-25/20508653.jpg" alt=""></p>
<p>通过带版本的共享内存解决多runs之间的重复事件问题。</p>
<h3 id="Computation-state"><a href="#Computation-state" class="headerlink" title="Computation state"></a>Computation state</h3><p><img src="http://or0igopk2.bkt.clouddn.com/18-2-25/48608682.jpg" alt=""></p>
<ol>
<li>version number of a run</li>
<li>current automaton state the run is in</li>
<li>a pointer to the most revent event selected into the buffer</li>
<li>a vector =&gt; 保留做edge判断的所需的最少的元素。例如上图中存储了a[i]的和和count为了计算平均值</li>
</ol>
<h3 id="Merge相同的Runs"><a href="#Merge相同的Runs" class="headerlink" title="Merge相同的Runs"></a>Merge相同的Runs</h3><p><img src="http://or0igopk2.bkt.clouddn.com/18-2-25/87062132.jpg" alt=""></p>
<p><img src="http://or0igopk2.bkt.clouddn.com/18-2-25/41465208.jpg" alt=""></p>
<p>将Query3中的avg算法改为max算法，他们在接收到e4之后达到了同样的状态，因此其之后的运算可以merge为一个。</p>
<ol>
<li>首先探测什么时候两个runs一样了，引入了算子M。每一个状态机都有一个mask，每一个mask对每一个Vector中列都有一个bit位，都相同时那么这两个run就是相等的。</li>
<li>创建combined的run<ol>
<li>时间设置为最小的那个时间</li>
</ol>
</li>
</ol>
<h3 id="Backtrack算法（回溯）"><a href="#Backtrack算法（回溯）" class="headerlink" title="Backtrack算法（回溯）"></a>Backtrack算法（回溯）</h3><p>每次只跑一个run，跑失败了再回退到分叉点跑另一条。也就是以广度优先搜索方式 <code>breadth first search manner</code></p>
<h3 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h3><ol>
<li>性能评估方案</li>
<li>有哪些因素会影响计算速度和吞吐</li>
<li>内存优化管理措施</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CEP实现论文&lt;/p&gt;
    
    </summary>
    
      <category term="论文" scheme="yoursite.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="Flink" scheme="yoursite.com/tags/Flink/"/>
    
      <category term="CEP" scheme="yoursite.com/tags/CEP/"/>
    
  </entry>
  
  <entry>
    <title>常阅读博客</title>
    <link href="yoursite.com/2018/01/23/%E5%B8%B8%E9%98%85%E8%AF%BB%E5%8D%9A%E5%AE%A2/"/>
    <id>yoursite.com/2018/01/23/常阅读博客/</id>
    <published>2018-01-23T01:58:30.000Z</published>
    <updated>2018-03-09T05:52:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>优秀可以常阅读汲取的博客</p>
<a id="more"></a>
<h2 id="java学习"><a href="#java学习" class="headerlink" title="java学习"></a>java学习</h2><p>java开发: <a href="http://www.cnblogs.com/xrq730/p/5260294.html" target="_blank" rel="external">http://www.cnblogs.com/xrq730/p/5260294.html</a><br>阿里工程师: <a href="http://www.hollischuang.com/" target="_blank" rel="external">http://www.hollischuang.com/</a><br>阿里中间件博客: <a href="http://jm.taobao.org/" target="_blank" rel="external">http://jm.taobao.org/</a><br>Jvm 你假笨: <a href="http://lovestblog.cn" target="_blank" rel="external">http://lovestblog.cn</a><br>RednaxelaFX: <a href="http://rednaxelafx.iteye.com/" target="_blank" rel="external">http://rednaxelafx.iteye.com/</a></p>
<h2 id="scala学习"><a href="#scala学习" class="headerlink" title="scala学习"></a>scala学习</h2><p><a href="http://hongjiang.info/scala/" target="_blank" rel="external">http://hongjiang.info/scala/</a></p>
<h2 id="流计算Flink"><a href="#流计算Flink" class="headerlink" title="流计算Flink"></a>流计算Flink</h2><p>阿里流计算工程师: <a href="http://www.cnblogs.com/fxjwind/" target="_blank" rel="external">http://www.cnblogs.com/fxjwind/</a><br>wuchong: <a href="http://wuchong.me/" target="_blank" rel="external">http://wuchong.me/</a><br>yuzhao: <a href="http://chenyuzhao.me/" target="_blank" rel="external">http://chenyuzhao.me/</a><br>vinoyang: <a href="http://blog.csdn.net/yanghua_kobe?viewmode=contents" target="_blank" rel="external">http://blog.csdn.net/yanghua_kobe?viewmode=contents</a><br>Imalds: <a href="http://blog.csdn.net/lmalds?viewmode=contents" target="_blank" rel="external">http://blog.csdn.net/lmalds?viewmode=contents</a></p>
<h2 id="大数据架构"><a href="#大数据架构" class="headerlink" title="大数据架构"></a>大数据架构</h2><p><a href="http://www.jasongj.com/" target="_blank" rel="external">http://www.jasongj.com/</a></p>
<h2 id="大数据hadoop"><a href="#大数据hadoop" class="headerlink" title="大数据hadoop"></a>大数据hadoop</h2><p><a href="http://blog.csdn.net/androidlushangderen" target="_blank" rel="external">http://blog.csdn.net/androidlushangderen</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;优秀可以常阅读汲取的博客&lt;/p&gt;
    
    </summary>
    
      <category term="杂" scheme="yoursite.com/categories/%E6%9D%82/"/>
    
    
  </entry>
  
  <entry>
    <title>flink中window实现的源码分析</title>
    <link href="yoursite.com/2018/01/07/Flink%20Window%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>yoursite.com/2018/01/07/Flink Window实现源码分析/</id>
    <published>2018-01-06T18:05:43.000Z</published>
    <updated>2018-01-07T03:17:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于Flink中window的实现分析</p>
<a id="more"></a>
<h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><p>window提供了一种处理无界数据的一种手段</p>
<h2 id="window的组件"><a href="#window的组件" class="headerlink" title="window的组件"></a>window的组件</h2><p>首先我们看window包含了哪些组件：触发器<code>trigger</code>，触发器上下文<code>triggerContext</code>，内部状态<code>windowState</code>，窗口分配器<code>windowassigner</code>, 内部时间服务器<code>internalTimerService</code>,初看到这么多的组件可能会有点懵，下面的分析会一点一点介绍这些组件的作用。</p>
<p>今天我们从flink接收流元素进行处理的角度来分析其实现，在flink的DAG中流动的有这么几种元素：<code>StreamRecord</code>,<code>LatencyRecord</code>,<code>WaterMark</code>,<code>StreamStatus</code>,我们这里只考虑这样两种元素<code>StreamRecord</code>和<code>WaterMark</code></p>
<h2 id="streamRecord"><a href="#streamRecord" class="headerlink" title="streamRecord"></a>streamRecord</h2><p>windowOperator实现了<code>KeyContext</code>,其实就是代表每一个windowOperator处理每一个元素就会在一个Key的上下文的环境中去做处理。</p>
<p>当windowOperator接收到一条<code>StreamRecord</code>,windowOperator会做什么呢?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">	numRecordsIn.inc();</div><div class="line">	streamOperator.setKeyContextElement1(record);</div><div class="line">	streamOperator.processElement(record);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>首先设置该operator的key为当前元素</li>
<li>根据element所携带的时间戳（processing time或者event  time）分配元素所应该属于的窗口，一个元素可能会隶属于多个窗口，比如slideWindowAssigner。</li>
<li>如果这个窗口是一个可merge窗口，例如session窗口，那么就会进行和原有窗口的合并和状态的更新</li>
</ol>
<h3 id="窗口merge原理"><a href="#窗口merge原理" class="headerlink" title="窗口merge原理"></a>窗口merge原理</h3><p><img src="http://or0igopk2.bkt.clouddn.com/18-1-7/74574325.jpg" alt=""></p>
<ol>
<li>首先取出之前的所有未清除的窗口，和新分配到的窗口做一次merge，有重叠部分则新生成大的窗口</li>
<li>将各个小窗口的真实数据merge到合并后的大窗口</li>
<li>注册大窗口的清理时间触发器，清理原先子窗口的清理时间触发器</li>
</ol>
<p>窗口merge完之后，则会通过<code>triggerContext#OnElement</code>方法去进行判断是否能触发计算，触发方式如前文分析wartermark的那样，就是通过wartermark来判断这个窗口是否可以进行计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onElement</span><span class="params">(Object element, <span class="keyword">long</span> timestamp, TimeWindow window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="keyword">if</span> (window.maxTimestamp() &lt;= ctx.getCurrentWatermark()) &#123;</div><div class="line">		<span class="comment">// if the watermark is already past the window fire immediately</span></div><div class="line">		<span class="keyword">return</span> TriggerResult.FIRE;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		ctx.registerEventTimeTimer(window.maxTimestamp());</div><div class="line">		<span class="keyword">return</span> TriggerResult.CONTINUE;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果不能触发计算，我们看到其实他是将<code>window.maxTimestamp</code>注册到了<code>eventTimeQueue</code>中, 这里我们先记一下，后文会提到他的作用。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里windowOperator接收到一个<code>StreamRecord</code>元素的处理逻辑已经结束了，如果窗口不是可merge类型的除了不做窗口merge，其他的操作也是大同小异，到这里也许你会有几个疑问(其实是我自己看代码的一些疑问：)</p>
<ol>
<li>如果我设置了allowLateness会对我们的计算结果产生什么样的影响呢？</li>
<li>我是用<code>apply()</code>,<code>process()</code>函数或者<code>reduce()</code>这种聚合函数对于window的<code>cost</code>代价有多大的差别？</li>
</ol>
<h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>上文中提到的在处理元素的最后会注册一个窗口cleanupTimer，那么这个时间是多少呢? <code>window.maxTimestamp() + allowedLateness;</code>  所以我们看到一个窗口存在时长是水位线经过<code>window的最大时间+allowLateness</code>的时间，因此当水位线大于窗口最大时间后就会触发计算，而计算之后状态不会清空，会保留<code>allowedLateness</code>的时长，而此时窗口状态还在保留，所以<strong>上游有晚到的数据来一条就会触发一次该窗口的计算</strong>，而且每次计算的数据都是该窗口的全量数据，所以业务方要慎用，或者下游要做好相应的去重或更新措施，否则可能会造成结果的不准确</p>
<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>不同的函数最终影响的其实是我们最终window保存数据的state的形式有<code>ListState</code>，也有<code>reducingState</code>…,最终影响了rocksdb和checkpoint的大小，不过肯定是能用聚合还是用聚合函数比较好</p>
<h2 id="waterMark"><a href="#waterMark" class="headerlink" title="waterMark"></a>waterMark</h2><p>当元素来的是一个watermark，window Operator又会以怎样的逻辑去处理呢?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleWatermark</span><span class="params">(Watermark watermark)</span> </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">			lastEmittedWatermark = watermark.getTimestamp();</div><div class="line">			operator.processWatermark(watermark);</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Exception occurred while processing valve output watermark: "</span>, e);		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们将关注到开篇提到的<code>internalTimeService</code>,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">advanceWatermark</span><span class="params">(<span class="keyword">long</span> time)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	currentWatermark = time;</div><div class="line"></div><div class="line">	InternalTimer&lt;K, N&gt; timer;</div><div class="line"></div><div class="line">	<span class="keyword">while</span> ((timer = eventTimeTimersQueue.peek()) != <span class="keyword">null</span> &amp;&amp; timer.getTimestamp() &lt;= time) &#123;</div><div class="line"></div><div class="line">		Set&lt;InternalTimer&lt;K, N&gt;&gt; timerSet = getEventTimeTimerSetForTimer(timer);</div><div class="line">		timerSet.remove(timer);</div><div class="line">		eventTimeTimersQueue.remove();</div><div class="line"></div><div class="line">		keyContext.setCurrentKey(timer.getKey());</div><div class="line">		triggerTarget.onEventTime(timer);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="watermark元素处理逻辑"><a href="#watermark元素处理逻辑" class="headerlink" title="watermark元素处理逻辑"></a>watermark元素处理逻辑</h3><p><img src="http://or0igopk2.bkt.clouddn.com/18-1-7/87202276.jpg" alt=""></p>
<ol>
<li>当流元素是watermark时主要处理逻辑集中在<code>internaltimerservice</code>上</li>
<li>如果<code>eventTimeTimersQueue</code>这个优先级队列中最早的时间低于了水位线，那么就会取出同一时刻的所有key的timer进行计算</li>
<li>处理可能意味着窗口的计算触发或者某些窗口的清理</li>
</ol>
<p>以上便是flink对于窗口的实现逻辑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Flink中window的实现分析&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Flink" scheme="yoursite.com/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>为什么现代系统架构需要一个新的编程模型 actor编程模型</title>
    <link href="yoursite.com/2017/12/17/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8E%B0%E4%BB%A3%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B--actor%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>yoursite.com/2017/12/17/为什么现代系统架构需要一个新的编程模型--actor编程模型/</id>
    <published>2017-12-17T13:32:20.000Z</published>
    <updated>2017-12-17T13:48:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>actor编程模型很早就由<code>Carl Hewitt</code>提出了, 最先是设计来解决在高性能的网络环境中的并发处理场景。只是当时没有这样的环境。如今，网络，硬件的基础设施的能力已经远远超越了那个时代，因此，当时提出的actor模型也有了用武之地。这篇文章讨论了关于传统编程的一些假设和现代实际的多线程，多核cpu架构不匹配的地方.</p>
<a id="more"></a>
<h1 id="封装所面临的挑战"><a href="#封装所面临的挑战" class="headerlink" title="封装所面临的挑战"></a>封装所面临的挑战</h1><p>OOP思想的支柱是封装，封装意味着对象中的数据是不能从外界直接访问的，他仅能够通过调用内部的方法被修改。因此对象就承担起暴露<strong>正确</strong>，<strong>安全</strong>的方法来保护其封装变量的不变性。举个例子，对一个顺序二叉树来说一定不允许违反一个二叉树的排序不变性。调用者期望二叉树的顺序在查询某段数据的时候能够保持不变，从而他们能够依赖于这种约束。<br>当我们分析OOP应用的运行行为时，我们通常会会画一个消息序列图标来展示方法调用之间的交互，例如：<br><img src="http://or0igopk2.bkt.clouddn.com/17-12-14/20018675.jpg" alt=""><br>不幸的是，上图没有精确的表达出，在执行的过程中这些对象的生命周期。实际上一个线程完成了所有这些调用。对变量不变性的要求是发生在方法调用的线程中：<br><img src="http://or0igopk2.bkt.clouddn.com/17-12-14/3331951.jpg" alt=""><br>这样展示的意义在于你对多线程的情况下建模会把问题变的清晰。当有多个线程的情况下，事情变的不一样。<br><img src="http://or0igopk2.bkt.clouddn.com/17-12-14/31370324.jpg" alt=""><br>我们可以看到中间有一个环节有两个线程进入了统一个方法，但是该对象的封装并没有考虑如何处理这种场景。这两个方法的调用可能是随机交叉的，这就导致要向保证其内部变量的不变一致行必须引入两个线程之间的协调机制,通常的做法是引入锁来解决这个问题，从而确保同一时间只有一个线程在调用该方法.然而：</p>
<ul>
<li>锁机制严重限制了并发度，他们在如今cpu的架构下代价很大，需要操作系统暂停线程然后再过段时间再恢复</li>
<li>调用线程在block之后不能再做其他的工作</li>
<li>锁还引入了死锁问题。</li>
</ul>
<p><strong>导致的结果</strong></p>
<ul>
<li>没有锁状态可能会导致冲突</li>
<li>引入锁，性能会受损，并容易导致死锁,并且锁一般适用于单机的情况，当有多台机器协调工作时，就需要分布式锁，通常比本地锁的性能更差，更影响其可扩展性。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>对象仅仅能够保证在单线程情况下内部状态的一致性</li>
<li>锁机制在生产实际中显示并不高效</li>
</ul>
<h1 id="现代计算机架构内存共享的问题"><a href="#现代计算机架构内存共享的问题" class="headerlink" title="现代计算机架构内存共享的问题"></a>现代计算机架构内存共享的问题</h1><p>在现代计算机架构中，如果我们定义一个变量，cpu是将其写入cpu缓存，而不是将其直接写到内存中，绝大多数是写到临近该cpu核的cache中去，因此不能被别的cpu core所见，为了让一些本地的修改能让其他的核所见，cpu cache需要将其中的数据刷到其他核中。<br>在jvm中我们通过<code>volatile</code>关键字来明确一块内存地址，这块内存会被所有线程共享。那么为什么我们不将所有的变量能标记为<code>volatile</code>呢？因为将cpu cache的数据传递到各个cpu核是代价非常高的事情</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>没有真正的共享内存，cpu将数据传输到别的cpu核上，就像在网络中做的一样，cpu内部通讯和网络的通讯在实现上也有很多的共通之处。</li>
<li>与其通过标记为共享或使用原子数据结构的变量来隐藏消息传递，更规范和原则性的方法是将状态信息保存到一个并发实体中，并通过消息的机制显式地传播并发实体之间的数据或事件</li>
</ul>
<h1 id="调用栈的说明"><a href="#调用栈的说明" class="headerlink" title="调用栈的说明"></a>调用栈的说明</h1><p>我们今天常常把所谓的堆栈视为理所当然，但是他们是在一个并发编程不那么重要的时代发明的，因为多cpu系统并不常见。调用堆栈不交叉线程，因此，不建模异步调用链。<br>当线程打算将任务委托给“后台任务”时，问题就出现了。实际上，这实际上意味着委托给另一个线程。这不能是一个简单的方法/函数调用，因为调用在线程中是严格的本地调用。通常发生的情况是，“调用者”将一个对象放入一个和被调用的工作线程共享的内存位置，这反过来调用者又可以在某个事件循环中获取它。这允许“caller”线程继续执行其他任务。<br>这种模式下第一个问题是，如何通知“调用者”任务已经完成了。当一个任务失败时，会出现一个更严重的问题。异常传播到什么地方?它将传播到工作线程的异常处理程序，而完全忽略实际的“调用者”是谁。就是无法将异常抛到主线程中去。<br><img src="http://or0igopk2.bkt.clouddn.com/17-12-17/52377993.jpg" alt=""><br>这是个严重的问题，工作的线程是如何处理这种情况的?它可能无法解决这个问题，因为它通常不知道失败的任务的目的“调用者”线程需要以某种方式被通知到，但是没有调用堆栈来解决异常。失败通知只能通过一个侧通道来完成，例如，在“调用者”线程希望得到结果的情况下，放置一个错误代码。如果此通知不到位，则“调用者”永远不会收到失败的通知，任务就会丢失!<strong>这与网络系统的工作方式惊人地相似，在没有任何通知的情况下，消息/请求可能会丢失/失败。</strong></p>
<p>这种情况再某些情况下会变得更糟，当一个由主线程发起的工作线程遇到了一个bug退出了最终会出现不可恢复的情况。一个由bug引起的内部异常会抛到线程的根，并使线程关闭。这立即引发了问题，谁应该重新启动由线程托管的服务的正常运行，以及如何恢复到已知的良好状态?乍一看，这似乎是可以管理的，但是我们突然面临一个新的、意想不到的现象。实际的任务，即线程当前正在进行的工作，不再位于任务从(通常是队列)中提取任务的共享内存位置。事实上，由于异常到达顶部，解除所有的调用堆栈，任务状态完全丢失!我们已经丢失了一条消息（即此时的工作线程已经退出），尽管这是本地通信，没有涉及到网络(消息丢失将被预期)。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>为了在当前系统上实现任何有意义的并发性和性能，线程必须在不阻塞的情况下以有效的方式将任务分配给彼此。有了这种任务委托并发机制(甚至更多的是通过网络/分布式计算)基于调用堆栈的错误处理，需要引入新的显式的错误信号机制。并且失败成为领域模型的一部分。</li>
<li>代理模式下的并发系统需要处理服务故障，并有方法从它们中恢复，此类服务的客户端需要意识到任务/消息可能在重新启动时丢失。即使没有发生损失，也可能由于先前的排队任务(长队列)、垃圾收集导致的延迟等原因导致响应延迟。在这些情况下，并发系统应该以超时的形式处理响应期限，就像网络/分布式系统一样。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>Akka 官网： <a href="https://doc.akka.io/docs/akka/2.5/guide/actors-motivation.html" target="_blank" rel="external">https://doc.akka.io/docs/akka/2.5/guide/actors-motivation.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;actor编程模型很早就由&lt;code&gt;Carl Hewitt&lt;/code&gt;提出了, 最先是设计来解决在高性能的网络环境中的并发处理场景。只是当时没有这样的环境。如今，网络，硬件的基础设施的能力已经远远超越了那个时代，因此，当时提出的actor模型也有了用武之地。这篇文章讨论了关于传统编程的一些假设和现代实际的多线程，多核cpu架构不匹配的地方.&lt;/p&gt;
    
    </summary>
    
      <category term="技术视角" scheme="yoursite.com/categories/%E6%8A%80%E6%9C%AF%E8%A7%86%E8%A7%92/"/>
    
    
      <category term="akka" scheme="yoursite.com/tags/akka/"/>
    
  </entry>
  
  <entry>
    <title>ArrayDeque源码分析</title>
    <link href="yoursite.com/2017/11/24/ArrayDeque%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>yoursite.com/2017/11/24/ArrayDeque实现源码分析/</id>
    <published>2017-11-24T07:32:23.000Z</published>
    <updated>2017-11-24T07:45:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于ArrayDeque源码分析</p>
<a id="more"></a>
<h1 id="Stack-and-Queue"><a href="#Stack-and-Queue" class="headerlink" title="Stack and Queue"></a>Stack and Queue</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java里有一个叫做<em>Stack</em>的类，却没有叫做<em>Queue</em>的类（它是个接口名字）。当需要使用栈时，Java已不推荐使用<em>Stack</em>，而是推荐使用更高效的<em>ArrayDeque</em>；既然<em>Queue</em>只是一个接口，当需要使用队列时也就首选<em>ArrayDeque</em>了（次选是<em>LinkedList</em>）。</p>
<ul>
<li>stack 先进后出</li>
<li>queue 先进先出</li>
</ul>
<h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>要讲栈和队列，首先要讲<em>Deque</em>接口。<em>Deque</em>的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了<em>Deque</em>与<em>Queue</em>相对应的接口：</p>
<table>
<thead>
<tr>
<th>Queue Method</th>
<th>Equivalent Deque Method</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add(e)</code></td>
<td><code>addLast(e)</code></td>
<td>向队尾插入元素，失败则抛出异常</td>
</tr>
<tr>
<td><code>offer(e)</code></td>
<td><code>offerLast(e)</code></td>
<td>向队尾插入元素，失败则返回<code>false</code></td>
</tr>
<tr>
<td><code>remove()</code></td>
<td><code>removeFirst()</code></td>
<td>获取并删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td><code>poll()</code></td>
<td><code>pollFirst()</code></td>
<td>获取并删除队首元素，失败则返回<code>null</code></td>
</tr>
<tr>
<td><code>element()</code></td>
<td><code>getFirst()</code></td>
<td>获取但不删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td><code>peek()</code></td>
<td><code>peekFirst()</code></td>
<td>获取但不删除队首元素，失败则返回<code>null</code></td>
</tr>
</tbody>
</table>
<p>下表列出了<em>Deque</em>与<em>Stack</em>对应的接口：</p>
<table>
<thead>
<tr>
<th>Stack Method</th>
<th>Equivalent Deque Method</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>push(e)</code></td>
<td><code>addFirst(e)</code></td>
<td>向栈顶插入元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td><code>offerFirst(e)</code></td>
<td>向栈顶插入元素，失败则返回<code>false</code></td>
</tr>
<tr>
<td><code>pop()</code></td>
<td><code>removeFirst()</code></td>
<td>获取并删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td><code>pollFirst()</code></td>
<td>获取并删除栈顶元素，失败则返回<code>null</code></td>
</tr>
<tr>
<td><code>peek()</code></td>
<td><code>peekFirst()</code></td>
<td>获取但不删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td><code>peekFirst()</code></td>
<td>获取但不删除栈顶元素，失败则返回<code>null</code></td>
</tr>
</tbody>
</table>
<p>上面两个表共定义了<em>Deque</em>的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。<strong>一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值（<code>false</code>或<code>null</code>）</strong>。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。<strong>虽然<em>Deque</em>的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看</strong>。明白了这一点讲解起来就会非常简单。</p>
<p><em>ArrayDeque</em>和<em>LinkedList</em>是<em>Deque</em>的两个通用实现，由于官方更推荐使用<em>AarryDeque</em>用作栈和队列，因为他更高效。<em>ArrayDeque的高效来源于head和tail这两个变量，它们使得物理上简单的从头到尾的数组变为了一个逻辑上循环的数组，避免了在头尾操作时的移</em></p>
<p>从名字可以看出<em>ArrayDeque</em>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<strong>循环数组（circular array）</strong>，也就是说数组的任何一点都可能被看作起点或者终点。<em>ArrayDeque</em>是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入<code>null</code>元素。</p>
<p><img src="http://or0igopk2.bkt.clouddn.com/17-11-24/2573607.jpg" alt=""></p>
<p>上图中我们看到，<strong><code>head</code>指向首端第一个有效元素，<code>tail</code>指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以<code>head</code>不一定总等于0，<code>tail</code>也不一定总是比<code>head</code>大。</p>
<h1 id="方法剖析"><a href="#方法剖析" class="headerlink" title="方法剖析"></a>方法剖析</h1><h2 id="两个重要索引"><a href="#两个重要索引" class="headerlink" title="两个重要索引"></a>两个重要索引</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一个元素的索引  </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> head;  </div><div class="line"><span class="comment">// 下个要添加元素的位置，为末尾元素的索引 + 1  </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> tail;</div></pre></td></tr></table></figure>
<ul>
<li>如果head和tail相同，则数组为空，长度为0。</li>
<li>如果tail大于head，则第一个元素为elements[head]，最后一个为elements[tail-1]，长度为tail-head，元素索引从head到tail-1。</li>
<li>如果tail小于head，且为0，则第一个元素为elements[head]，最后一个为elements[elements.length-1]，元素索引从head到elements.length-1。</li>
<li>如果tail小于head，且大于0，则会形成循环，第一个元素为elements[head]，最后一个是elements[tail-1]，元素索引从head到elements.length-1，然后再从0到tail-1</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>&#123;  </div><div class="line">    elements = (E[]) <span class="keyword">new</span> Object[<span class="number">16</span>]; <span class="comment">// 默认的数组长度大小  </span></div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;  </div><div class="line">    allocateElements(numElements); <span class="comment">// 需要的数组长度大小  </span></div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">    allocateElements(c.size()); <span class="comment">// 根据集合来分配数组大小  </span></div><div class="line">    addAll(c); <span class="comment">// 把集合中元素放到数组中  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里看出要么是创建默认的16大小的数组，要么是<code>allocateElements(size)</code>去进行动态调整。</p>
<h2 id="分配的逻辑"><a href="#分配的逻辑" class="headerlink" title="分配的逻辑"></a>分配的逻辑</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;  </div><div class="line">    <span class="comment">// 找到大于需要长度的最小的2的幂整数。  </span></div><div class="line">    <span class="comment">// Tests "&lt;=" because arrays aren't kept full.  </span></div><div class="line">    <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;  </div><div class="line">        initialCapacity = numElements;  </div><div class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);  </div><div class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);  </div><div class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);  </div><div class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);  </div><div class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);  </div><div class="line">        initialCapacity++;  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back off  </span></div><div class="line">            initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">// Good luck allocating 2 ^ 30 elements  </span></div><div class="line">    &#125;  </div><div class="line">    elements = (E[]) <span class="keyword">new</span> Object[initialCapacity];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码的晦涩之处在于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</div><div class="line">initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</div><div class="line">initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</div><div class="line">initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</div><div class="line">initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line"></div><div class="line">initialCapacity++;</div></pre></td></tr></table></figure>
<ul>
<li>如果numElements小于MIN_INITIAL_CAPACITY，则分配的数组长度就是MIN_INITIAL_CAPACITY，它是一个静态常量，值为8。</li>
<li>在numElements大于等于8的情况下，分配的实际长度是严格大于numElements并且为2的整数次幂的最小数。比如，如果numElements为10，则实际分配16，如果numElements为32，则为64。</li>
</ul>
<p>为什么要为2的幂次数呢？我们待会会看到，这样会使得很多操作的效率很高。</p>
<p>为什么要严格大于numElements呢？因为循环数组必须时刻至少留一个空位，tail变量指向下一个空位，为了容纳numElements个元素，至少需要numElements+1个位置</p>
<p>这究竟在干什么？其实，它是在将initialCapacity左边最高位的1复制到右边的每一位，这种复制类似于病毒复制，是1传2、2传4、4传8式的指数级复制，最后再执行initialCapacity++就可以得到比initialCapacity大且为2的幂次方的最小的数。  这个操作可以在<code>Hackers Delight</code>这本书中找到原型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="comment">// HD, Figure 3-1</span></div><div class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);</div><div class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);</div><div class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);</div><div class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);</div><div class="line">    i |= (i &gt;&gt; <span class="number">16</span>);</div><div class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst()"></a>addFirst()</h2><p><code>addFirst(E e)</code>的作用是在<em>Deque</em>的首端插入元素，也就是在<code>head</code>的前面插入元素，在空间足够且下标没有越界的情况下，只需要将<code>elements[--head] = e</code>即可。</p>
<p><img src="http://or0igopk2.bkt.clouddn.com/17-11-24/76601566.jpg" alt=""></p>
<p>实际需要考虑：</p>
<ol>
<li>空间是否够用</li>
<li>下标是否越界的问题。上图中，如果<code>head</code>为<code>0</code>之后接着调用<code>addFirst()</code>，虽然空余空间还够用，但<code>head</code>为<code>-1</code>，下标越界了。下列代码很好的解决了这两个问题。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//addFirst(E e)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;<span class="comment">//2.下标是否越界</span></div><div class="line">    <span class="keyword">if</span> (head == tail)<span class="comment">//1.空间是否够用</span></div><div class="line">        doubleCapacity();<span class="comment">//扩容</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为<code>tail</code>总是指向下一个可插入的空位，也就意味着<code>elements</code>数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p>
<p>下标越界的处理解决起来非常简单，<code>head = (head - 1) &amp; (elements.length - 1)</code>就可以了，<strong>这段代码相当于取余，同时解决了<code>head</code>为负值的情况</strong>。由上述分配空间的代码可以看出<code>elements.length</code>必是<code>2</code>的指数倍，<code>elements.length - 1</code>就是二进制低位全<code>1</code>，无论是正数还是负数，跟<code>head - 1</code>相与之后就起到了取模的作用，如果<code>head - 1</code>为负数（其实只可能是-1），则相当于对其取相对于<code>elements.length</code>的补码。</p>
<p>比如说，如果elements.length为8，则(elements.length - 1)为7，二进制为0111，对于负数-1，与7相与，结果为7，对于正数8，与7相与，结果为0，都能达到循环数组中找下一个正确位置的目的。</p>
<p>下面再说说扩容函数<code>doubleCapacity()</code>，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：</p>
<p><img src="http://or0igopk2.bkt.clouddn.com/17-11-24/65385427.jpg" alt=""></p>
<p>图中我们看到，复制分两次进行，第一次复制<code>head</code>右边的元素，第二次复制<code>head</code>左边的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//doubleCapacity()</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> head == tail;</div><div class="line">    <span class="keyword">int</span> p = head;</div><div class="line">    <span class="keyword">int</span> n = elements.length;</div><div class="line">    <span class="keyword">int</span> r = n - p; <span class="comment">// head右边元素的个数</span></div><div class="line">    <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;<span class="comment">//原空间的2倍</span></div><div class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Sorry, deque too big"</span>);</div><div class="line">    Object[] a = <span class="keyword">new</span> Object[newCapacity];</div><div class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);<span class="comment">//复制右半部分，对应上图中绿色部分</span></div><div class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);<span class="comment">//复制左半部分，对应上图中灰色部分</span></div><div class="line">    elements = (E[])a;</div><div class="line">    head = <span class="number">0</span>;</div><div class="line">    tail = n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="pollFirst"><a href="#pollFirst" class="headerlink" title="pollFirst()"></a>pollFirst()</h2><p><code>pollFirst()</code>的作用是删除并返回<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素。如果容器不空，只需要直接返回<code>elements[head]</code>即可，当然还需要处理下标的问题。由于<code>ArrayDeque</code>中不允许放入<code>null</code>，当<code>elements[head] == null</code>时，意味着容器为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">    E result = elements[head];</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)<span class="comment">//null值意味着deque为空</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    elements[h] = <span class="keyword">null</span>;<span class="comment">//let GC work</span></div><div class="line">    head = (head + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);<span class="comment">//下标越界处理</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="pollLast"><a href="#pollLast" class="headerlink" title="pollLast()"></a>pollLast()</h2><p><code>pollLast()</code>的作用是删除并返回<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);<span class="comment">//tail的上一个位置是最后一个元素</span></div><div class="line">    E result = elements[t];</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)<span class="comment">//null值意味着deque为空</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    elements[t] = <span class="keyword">null</span>;<span class="comment">//let GC work</span></div><div class="line">    tail = t;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="peekFirst"><a href="#peekFirst" class="headerlink" title="peekFirst()"></a>peekFirst()</h2><p><code>peekFirst()</code>的作用是返回但不删除<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素，直接返回<code>elements[head]</code>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> elements[head]; <span class="comment">// elements[head] is null if deque empty</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="peekLast"><a href="#peekLast" class="headerlink" title="peekLast()"></a>peekLast()</h2><p><code>peekLast()</code>的作用是返回但不删除<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/CarpenterLee/JCFInternals/tree/master/markdown" target="_blank" rel="external">https://github.com/CarpenterLee/JCFInternals/tree/master/markdown</a></p>
<p><a href="http://czj4451.iteye.com/blog/1688693" target="_blank" rel="external">http://czj4451.iteye.com/blog/1688693</a></p>
<p><a href="https://www.cnblogs.com/swiftma/p/6029547.html" target="_blank" rel="external">https://www.cnblogs.com/swiftma/p/6029547.html</a></p>
<p><a href="https://stackoverflow.com/questions/28314798/addfirst-method-of-arraydeque-class" target="_blank" rel="external">https://stackoverflow.com/questions/28314798/addfirst-method-of-arraydeque-class</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于ArrayDeque源码分析&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="jdk" scheme="yoursite.com/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>flink-watermark</title>
    <link href="yoursite.com/2017/09/10/flink-watermark/"/>
    <id>yoursite.com/2017/09/10/flink-watermark/</id>
    <published>2017-09-10T07:59:23.000Z</published>
    <updated>2017-09-10T08:13:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于Flink中watermark工作原理代码分析</p>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>waterMark，latency，checkpoint这三者实现方式都是上游节点逐步广播消息给下游节点来处理的行为（都是在流中插入一种特殊的数据结构来做处理）</p>
<h3 id="时间语义"><a href="#时间语义" class="headerlink" title="时间语义"></a>时间语义</h3><p>谈及watermark就要先从Flink支持的时间语义说起，Flink支持三种时间语义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">process time:指的系统处理对应数据时的系统时间。他是最简单的一种实现，由于不需要额外的协调，因性能最好</div><div class="line">event time:是指数据中携带的时间，而不是数据到达的时间。因此时间的进度完全取决于数据，而不是系统时间。使用event time必须指定生成eventTime和watermark的方式。因为他一般会等待迟到的数据，因此一定会有一定的延时</div><div class="line">ingestion time:是指数据进入flink的时间，在source处插入的时间，和process time一样无法处乱序事件</div></pre></td></tr></table></figure>
<p>对于eventtime和ingestion time两种语义到达的数据有可能乱序的。从事件产生（例如日志采集数据中的乱序日志），到流经source，再到operator，中间是有一个过程时间的。虽然大部分情况下，流到operator的数据都是按照事件产生的时间顺序来的，但是也不排除由于网络、背压等原因，导致乱序的产生（out-of-order或者说late element）。<br>但是对于late element，我们又不能无限期的等下去，必须要有个机制来保证一个特定的时间后，必须触发window去进行计算了。这个特别的机制，就是watermark，它告诉了算子时间不大于 WaterMark 的消息不应该再被接收【如果出现意味着延迟到达】。也就是说水位线以下的数据均已经到达。WaterMark 从源算子开始 emit，并逐级向下游算子传递。当源算子关闭时，会发射一个携带 Long.MAX_VALUE 值时间戳的 WaterMark，下游算子接收到之后便知道不会再有消息到达。</p>
<h3 id="waterMark产生方式"><a href="#waterMark产生方式" class="headerlink" title="waterMark产生方式"></a>waterMark产生方式</h3><p>waterMark的产生:有两种方式来产生watermark和timestamp</p>
<ol>
<li>在数据源处直接进行assign timestamp 和generate watermark</li>
<li>通过timestamp和watermark generate operator来产生，如果使用了timestamp assigner和watermark generator在source处产生的timestamp和watermark会被覆盖。</li>
<li>其实这两种最终的实现方式还是一样的！即第一种也是在source处分配了timestampAssigner</li>
</ol>
<h4 id="方法一-在数据源处产生发送"><a href="#方法一-在数据源处产生发送" class="headerlink" title="方法一 在数据源处产生发送"></a>方法一 在数据源处产生发送</h4><p>目前实现了在source提取时间和产生operator的只有0.10版本的kafka fetcher中实现<br>首先根据应用<code>StreamExecutionEnvironment#setStreamTimeCharacteristic</code>设置的时间语义（存储于<code>StreamConfig</code>类）来获取<br>对应的sourceContext，sourceContext接口是sourceFunction发送数据的抽象，有三个实现类，根据时间语义划分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (timeCharacteristic) &#123;</div><div class="line">            <span class="keyword">case</span> EventTime:</div><div class="line">                ctx = <span class="keyword">new</span> ManualWatermarkContext&lt;&gt;(checkpointLock, output);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> IngestionTime:</div><div class="line">                ctx = <span class="keyword">new</span> AutomaticWatermarkContext&lt;&gt;(processingTimeService, checkpointLock, output, watermarkInterval);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> ProcessingTime:</div><div class="line">                ctx = <span class="keyword">new</span> NonTimestampContext&lt;&gt;(checkpointLock, output);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.valueOf(timeCharacteristic));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ctx;</div></pre></td></tr></table></figure>
<p>这里我们就考虑eventTime的情况。<br>在kafka AbstractFetcher中还提供了三种模式来控制自己生产时间戳和watermark</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NO_TIMESTAMPS_WATERMARKS: fetcher 不生产 timestamp 和 watermarks</div><div class="line">PERIODIC_WATERMARKS: fetcher 阶段性定时生产 watermarks</div><div class="line">PUNCTUATED_WATERMARKS: fetcher 生产标记 watermark 【按照特定的消息字段值触发】</div></pre></td></tr></table></figure>
<p>这里的区分方式来自于<code>FlinkKafkaConsumerBase#assignTimestampsAndWatermarks</code>分配的<code>AssignerWithPunctuatedWatermarks</code>或<code>AssignerWithPeriodicWatermarks</code> 也就是assigner决定了产生方式，这其实就是把方法二给封装到了KafkaConsumerBase里面！当然这个也需要用户在创建consumer之后自定义一个assigner。</p>
<h4 id="方法二-使用TimestampAssigner来实现"><a href="#方法二-使用TimestampAssigner来实现" class="headerlink" title="方法二 使用TimestampAssigner来实现"></a>方法二 使用TimestampAssigner来实现</h4><p>TimestampAssinger是接收一个流，并产生一个新的流带上了时间戳和watermark，如果原来的流已经带有了timestamp和watermark那么这个将会被覆盖。timestamp assinger只需要在关于时间的操作之前加上即可。</p>
<p>flink通过接口<code>TimestampAssigner</code>来让用户依据消息的格式自己抽取可能被用于 WaterMark的timestamp，它只定义了一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(T element, <span class="keyword">long</span> previousElementTimestamp)</span></span>;</div></pre></td></tr></table></figure>
<p>previousElementTimestamp这个参数传入的是什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">long</span> newTimestamp = userFunction.extractTimestamp(value, </div><div class="line">				element.hasTimestamp() ? element.getTimestamp() : Long.MIN_VALUE);</div><div class="line">因此如果一个元素如果已经带有timestamp，比如在source处已经分配，那么在这里处理的时候会被覆盖掉。</div></pre></td></tr></table></figure>
<p>而<code>TimestampAssigner</code>的两个继承接口<code>AssignerWithPunctuatedWatermarks</code>以及 <code>AssignerWithPeriodicWatermarks</code> 定义了waterMark生成的两种典型方式。</p>
<h5 id="AssignerWithPeriodicWatermarks"><a href="#AssignerWithPeriodicWatermarks" class="headerlink" title="AssignerWithPeriodicWatermarks"></a>AssignerWithPeriodicWatermarks</h5><p><code>AssignerWithPeriodicWatermarks</code>是周期性的产生watermark，每过一定间隔   <code>ExecutionConfig#getAutoWatermarkInterval()</code>，系统会调用<code>getCurrentWatermark</code>来获取最新的waterMark值，如果新的waterMark值有增长那么就会发送一个新的waterMark，如果没有新的元素进来，那么getCurrentWatermark则不会被周期性的调用，这个接口的好处是，可以定义最大乱序时间，减少因为数据延迟到达而被时间窗口丢弃的行为，实现类<code>BoundedOutOfOrdernessTimestampExtractor</code></p>
<h5 id="AssignerWithPunctuatedWatermarks"><a href="#AssignerWithPunctuatedWatermarks" class="headerlink" title="AssignerWithPunctuatedWatermarks"></a>AssignerWithPunctuatedWatermarks</h5><p><code>AssignerWithPunctuatedWatermarks</code>的使用场景是针对在接收到特定的elements之后才触发更新waterMark的操作。比如有一个流中有一些元素带有flag表示没有晚于这个元素时间的元素了,那么他的实现代码是这样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatermarkOnFlagAssigner</span> <span class="keyword">implements</span> <span class="title">AssignerWithPunctuatedWatermarks</span>&lt;<span class="title">MyElement</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(MyElement element, <span class="keyword">long</span> previousElementTimestamp)</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> element.getSequenceTimestamp();</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">public</span> Watermark <span class="title">checkAndGetNextWatermark</span><span class="params">(MyElement lastElement, <span class="keyword">long</span> extractedTimestamp)</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> lastElement.isEndOfSequence() ? <span class="keyword">new</span> Watermark(extractedTimestamp) : <span class="keyword">null</span>;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>我们平常用的最多的还是<code>AssignerWithPeriodicWatermarks</code> 并设置数据到达最大超时时长。下面的分析我们就以<code>AssignerWithPeriodicWatermarks</code>为例。<br>想到一个点<code>AssignerWithPunctuatedWatermarks</code>的一个使用场景:可能比较适合于数据不是连续发送或者说是批任务的场景，比如说是每天某时候数据有更新之后才有计算，那么只要在进入的最后一个数据打入endFlag，然后进行waterMark更新触发数据处理（一个想法，尚未实践）。</p>
<h3 id="waterMark在传输及对window-Operator的作用方式"><a href="#waterMark在传输及对window-Operator的作用方式" class="headerlink" title="waterMark在传输及对window Operator的作用方式"></a>waterMark在传输及对window Operator的作用方式</h3><h4 id="TimestampsAndPeriodicWatermarksOperator"><a href="#TimestampsAndPeriodicWatermarksOperator" class="headerlink" title="TimestampsAndPeriodicWatermarksOperator"></a>TimestampsAndPeriodicWatermarksOperator</h4><p>在DataStream调用<code>assignTimestampsAndWatermarks</code>产生了一个<code>TimestampsAndPeriodicWatermarksOperator</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line"><span class="function"><span class="keyword">public</span> SingleOutputStreamOperator&lt;T&gt; <span class="title">assignTimestampsAndWatermarks</span><span class="params">(</span></span></div><div class="line">	AssignerWithPeriodicWatermarks&lt;T&gt; timestampAndWatermarkAssigner) &#123;</div><div class="line">		</div><div class="line">	<span class="comment">// match parallelism to input, otherwise dop=1 sources could lead to some strange</span></div><div class="line">	<span class="comment">// behaviour: the watermark will creep along very slowly because the elements</span></div><div class="line">	<span class="comment">// from the source go to each extraction operator round robin.</span></div><div class="line">	<span class="comment">//这里就是说一般会默认将并发度设成和inputOperator的并发度一致，避免因为elements进入extraction operator的时候要随机进入分区。</span></div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> inputParallelism = getTransformation().getParallelism();</div><div class="line">	<span class="keyword">final</span> AssignerWithPeriodicWatermarks&lt;T&gt; cleanedAssigner = clean(timestampAndWatermarkAssigner);</div><div class="line">		</div><div class="line">	TimestampsAndPeriodicWatermarksOperator&lt;T&gt; operator = </div><div class="line">			<span class="keyword">new</span> TimestampsAndPeriodicWatermarksOperator&lt;&gt;(cleanedAssigner);</div><div class="line">		</div><div class="line">	<span class="keyword">return</span> transform(<span class="string">"Timestamps/Watermarks"</span>, getTransformation().getOutputType(), operator)</div><div class="line">			.setParallelism(inputParallelism);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看这个<code>TimestampsAndPeriodicWatermarksOperator</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="keyword">super</span>.open();</div><div class="line"></div><div class="line">	currentWatermark = Long.MIN_VALUE;</div><div class="line">	watermarkInterval = getExecutionConfig().getAutoWatermarkInterval();</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (watermarkInterval &gt; <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">long</span> now = getProcessingTimeService().getCurrentProcessingTime();</div><div class="line">		getProcessingTimeService().registerTimer(now + watermarkInterval, <span class="keyword">this</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProcessingTime</span><span class="params">(<span class="keyword">long</span> timestamp)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="comment">// register next timer</span></div><div class="line">	Watermark newWatermark = userFunction.getCurrentWatermark();</div><div class="line">	<span class="keyword">if</span> (newWatermark != <span class="keyword">null</span> &amp;&amp; newWatermark.getTimestamp() &gt; currentWatermark) &#123;</div><div class="line">		currentWatermark = newWatermark.getTimestamp();</div><div class="line">		<span class="comment">// emit watermark</span></div><div class="line">		output.emitWatermark(newWatermark);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">long</span> now = getProcessingTimeService().getCurrentProcessingTime();</div><div class="line">	getProcessingTimeService().registerTimer(now + watermarkInterval, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这两个方法，会从TimestampsAndPeriodicWatermarksOperator定期<code>watermarkInterval</code>发送<code>userFunction.getCurrentWatermark()</code>用户定义的waterMark,当然也是要waterMark有上涨的情况下才会发送</p>
<p>而且这里有个有意思的地方,这里也定义了<code>processWatermark</code>方法，该方法主要调用时机主要，是在<code>StreamInputProcessor#processInput</code>中,这个类在后面再具体分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processWatermark</span><span class="params">(Watermark mark)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="comment">// if we receive a Long.MAX_VALUE watermark we forward it since it is used</span></div><div class="line">	<span class="comment">// to signal the end of input and to not block watermark progress downstream</span></div><div class="line">	<span class="keyword">if</span> (mark.getTimestamp() == Long.MAX_VALUE &amp;&amp; currentWatermark != Long.MAX_VALUE) &#123;</div><div class="line">		currentWatermark = Long.MAX_VALUE;</div><div class="line">		output.emitWatermark(mark);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是这里覆盖了<code>AbstractStreamOperator</code>中的写法是为什么呢?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processWatermark</span><span class="params">(Watermark mark)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="keyword">for</span> (HeapInternalTimerService&lt;?, ?&gt; service : timerServices.values()) &#123;</div><div class="line">		service.advanceWatermark(mark.getTimestamp());</div><div class="line">	&#125;</div><div class="line">	output.emitWatermark(mark);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里其实体现了在最后一个<code>TimestampsAndPeriodicWatermarksOperator</code>之前定义的waterMark传递此operator的时候除非是一个流结束标志<code>Long.MAX_VALUE</code>,否则不会发送，只会有该operator定时发送waterMark给下游处理，这也就说明了在source处定义的waterMark会被后面定义的给覆盖。</p>
<p>所以大部分Operator处理waterMark的方式是<code>AbstractStreamOperator</code>中定义好的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processWatermark</span><span class="params">(Watermark mark)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="keyword">for</span> (HeapInternalTimerService&lt;?, ?&gt; service : timerServices.values()) &#123;</div><div class="line">		service.advanceWatermark(mark.getTimestamp());<span class="comment">//这个处理逻辑还要在看下</span></div><div class="line">	&#125;</div><div class="line">	output.emitWatermark(mark);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里看到他是会给所有的下游channel发送一个watermark</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emitWatermark</span><span class="params">(Watermark mark)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span> (Output&lt;StreamRecord&lt;OUT&gt;&gt; out : allOutputs) &#123;</div><div class="line">		out.emitWatermark(mark);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="StreamInputProcessor"><a href="#StreamInputProcessor" class="headerlink" title="StreamInputProcessor"></a>StreamInputProcessor</h4><p>processWatermark是在<code>StreamInputprocessor</code>中调用的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (recordOrMark.isWatermark()) &#123;</div><div class="line">		<span class="keyword">long</span> watermarkMillis = recordOrMark.asWatermark().getTimestamp();</div><div class="line">		<span class="keyword">if</span> (watermarkMillis &gt; watermarks[currentChannel]) &#123;</div><div class="line">			watermarks[currentChannel] = watermarkMillis;</div><div class="line">			<span class="keyword">long</span> newMinWatermark = Long.MAX_VALUE;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">long</span> watermark: watermarks) &#123;</div><div class="line">				newMinWatermark = Math.min(watermark, newMinWatermark);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (newMinWatermark &gt; lastEmittedWatermark) &#123;</div><div class="line">				lastEmittedWatermark = newMinWatermark;</div><div class="line">				<span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">					streamOperator.processWatermark(<span class="keyword">new</span> Watermark(lastEmittedWatermark));</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">continue</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>逻辑总结:（channel的理解还不够）</p>
<ol>
<li>如果消费到的消息是一个 WaterMark，获得其对应的 source channel id 并将时间更新进去，同时记录下当前所有 channel 的最小 WaterMark 时间</li>
<li>如果当前最小 WaterMark 时间【所有的 channel 都至少消费到该时间】大于上次发射给下游的 WaterMark 时间，则更新 WaterMark 时间并将其交给算子处理</li>
<li>通常算子在处理【尤其是涉及了窗口计算或者需要时间缓存策略的算子】后会将 WaterMark 继续往下游广播发送</li>
</ol>
<h3 id="waterMark对window作用形式"><a href="#waterMark对window作用形式" class="headerlink" title="waterMark对window作用形式"></a>waterMark对window作用形式</h3><p>waterMark如何触发窗口计算</p>
<h4 id="情况一-late-element"><a href="#情况一-late-element" class="headerlink" title="情况一: late element"></a>情况一: late element</h4><ul>
<li>Event Time &lt; watermark时间（对于late element太多的数据而言）,这种情况下只要来一条数据就会触发窗口计算，其他属于该窗口的数据到达后都会被丢弃。</li>
</ul>
<h4 id="情况二：乱序"><a href="#情况二：乱序" class="headerlink" title="情况二：乱序"></a>情况二：乱序</h4><ul>
<li>watermark时间 &gt;= window_end_time（对于out-of-order以及正常的数据而言）</li>
<li>在[window_start_time,window_end_time)中有数据存在</li>
</ul>
<p>window的触发机制，是先按照自然时间将window划分，如果window大小是3秒，那么1分钟内会把window划分为如下的形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[00:00:00,00:00:03)</div><div class="line">[00:00:03,00:00:06)</div><div class="line">...</div><div class="line">[00:00:57,00:01:00)</div></pre></td></tr></table></figure>
<p>如果window大小是10秒，则window会被分为如下的形式：当然还有一个offset值可以控制window的起始值不是整点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[00:00:00,00:00:10)</div><div class="line">[00:00:10,00:00:20)</div><div class="line">...</div><div class="line">[00:00:50,00:01:00)</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onElement</span><span class="params">(Object element, <span class="keyword">long</span> timestamp, TimeWindow window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="keyword">if</span> (window.maxTimestamp() &lt;= ctx.getCurrentWatermark()) &#123;</div><div class="line">		<span class="comment">// if the watermark is already past the window fire immediately</span></div><div class="line">		<span class="keyword">return</span> TriggerResult.FIRE;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		ctx.registerEventTimeTimer(window.maxTimestamp());</div><div class="line">		<span class="keyword">return</span> TriggerResult.CONTINUE;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到<code>EventTimeTrigger</code>中当<code>ctx.getCurrentWatermark &gt; window.maxTimestamp</code>时立刻触发窗口计算.</p>
<p>当然没有内容是不会触发计算的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (triggerResult.isFire()) &#123;</div><div class="line">					ACC contents = windowState.get();</div><div class="line">					<span class="keyword">if</span> (contents == <span class="keyword">null</span>) &#123;</div><div class="line">						<span class="keyword">continue</span>;</div><div class="line">					&#125;</div><div class="line">					emitWindowContents(actualWindow, contents);</div><div class="line">				&#125;</div></pre></td></tr></table></figure>
<p>输入的数据中，根据自身的Event Time，将数据划分到不同的window中，如果window中有数据，则当watermark时间&gt;=window_edn_time时，就符合了window触发的条件了，最终决定window触发，还是由数据本身的Event Time所属的window中的window_end_time决定。</p>
<p>以上代码和情况二相符，其实情况一也是情况二的特殊情况，watermark &gt; 数据的 eventtime也就是说超过了最大的延迟时间，此时其实也是来了之后watermark &gt; window.endtime，然后必然会被触发只是其他该窗格的数据会被丢弃罢了。</p>
<p>数据清理的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isLate</span><span class="params">(W window)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> (windowAssigner.isEventTime() &amp;&amp; (cleanupTime(window) &lt;= internalTimerService.currentWatermark()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">cleanupTime</span><span class="params">(W window)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (windowAssigner.isEventTime()) &#123;</div><div class="line">			<span class="keyword">long</span> cleanupTime = window.maxTimestamp() + allowedLateness;</div><div class="line">			<span class="keyword">return</span> cleanupTime &gt;= window.maxTimestamp() ? cleanupTime : Long.MAX_VALUE;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> window.maxTimestamp();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>最大乱序时间要结合自己的业务以及数据情况去设置。如果maxOutOfOrderness设置的太小，而自身数据发送时由于网络等原因导致乱序或者late太多，那么最终的结果就是会有很多单条的数据在window中被触发，数据的正确性影响太大，对此可以通过在windowOperator处添加metrics监控来指导业务方设置成什么样的一个值才是最合理的。</p>
<h4 id="allowLatency"><a href="#allowLatency" class="headerlink" title="allowLatency"></a>allowLatency</h4><p>最后一点上文代码里提到的这个allowLatency又有什么作用呢?</p>
<p>默认情况下当watermark涨过了window的endtime之后，再有属于该窗口的数据到来的时候该数据会被丢弃，设置了allowLatency这个值之后，也就是定义了数据在watermark涨过window.endtime但是又在allowlatency之前到达的话仍旧会被加到对应的窗口去。会使得窗口<strong>再次</strong>被触发。Flink会保存窗口的状态直到allow latenness 超期。</p>
<p>待补充：</p>
<ol>
<li>对流传输过程中channel的理解</li>
<li>keyby操作过程对watermark的影响 </li>
<li>advanceWatermark操作理解</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/lmalds/article/details/52704170" target="_blank" rel="external">http://blog.csdn.net/lmalds/article/details/52704170</a><br><a href="http://chenyuzhao.me/2017/02/09/flink-watermark-checkpoint/" target="_blank" rel="external">http://chenyuzhao.me/2017/02/09/flink-watermark-checkpoint/</a><br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/dev/event_timestamps_watermarks.html" target="_blank" rel="external">https://ci.apache.org/projects/flink/flink-docs-release-1.2/dev/event_timestamps_watermarks.html</a><br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.2/dev/windows.html#allowed-lateness" target="_blank" rel="external">https://ci.apache.org/projects/flink/flink-docs-release-1.2/dev/windows.html#allowed-lateness</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Flink中watermark工作原理代码分析&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Flink" scheme="yoursite.com/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>flink-latency-tracker</title>
    <link href="yoursite.com/2017/09/09/flink-latency-tracker/"/>
    <id>yoursite.com/2017/09/09/flink-latency-tracker/</id>
    <published>2017-09-08T16:47:35.000Z</published>
    <updated>2017-09-10T08:03:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于Flink中的Latency track</p>
<a id="more"></a>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>为了监控Flink数据端到端的数据延迟</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>定时在source处定时的发送一个特殊的event，类似于watermark的处理方式，这里叫做LatencyMark。</li>
<li>latencyMarker仅在source处产生,latencyMarker对象包含的是source operator的区分标志 subIndex以及vertexID（根据subIndex以及vertexID区分是否是同一个Marker）以及携带了发送的时间</li>
<li>LatencyMark在各个operator间传递，在每个operator处将会比较LatencyMark和它当前的系统时间来决定延迟的大小，并存入LatencyGauge，每一个operator都会维护这样一个Metric（因此LatencyMark的实现就是基于TM和JM集群的机器系统时间是进行过同步的）</li>
<li>当Operator有多个Output的时候，他会随机选择一个来发送，这确保了每一个Marker在整个流中只会出现一次，repartition也不会导致LatencyMark的数量暴增。<br>在sink operator处会维护source的最近128个latencyMarker，通过一个LatencyGauge来展示</li>
</ol>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>默认latencyTrackingInterval是2000，也就是2s发送一个LatencyMarker。在StreamSource中判断，如果开启了latency track.那么就会定期发送LatencyMarker。</p>
<p>在StreamSource（Operator）中的定时发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">latencyMarkTimer = processingTimeService.scheduleAtFixedRate(</div><div class="line">   <span class="keyword">new</span> ProcessingTimeCallback() &#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProcessingTime</span><span class="params">(<span class="keyword">long</span> timestamp)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// ProcessingTimeService callbacks are executed under the checkpointing lock</span></div><div class="line">            output.emitLatencyMarker(<span class="keyword">new</span> LatencyMarker(timestamp, vertexID, subtaskIndex));</div><div class="line">         &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            <span class="comment">// we catch the Throwables here so that we don't trigger the processing</span></div><div class="line">            <span class="comment">// timer services async exception handler</span></div><div class="line">            LOG.warn(<span class="string">"Error while emitting latency marker."</span>, t);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;,</div><div class="line">   <span class="number">0L</span>,</div><div class="line">   latencyTrackingInterval);</div></pre></td></tr></table></figure>
<p>在Operator中处理：首先进行LatencyMarker处理再发送，<br>在AbstractStreamOperator类中定义的latencyMarker处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportLatency</span><span class="params">(LatencyMarker marker, <span class="keyword">boolean</span> isSink)</span> </span>&#123;</div><div class="line">   LatencySourceDescriptor sourceDescriptor = LatencySourceDescriptor.of(marker, !isSink);</div><div class="line">   DescriptiveStatistics sourceStats = latencyStats.get(sourceDescriptor);</div><div class="line">   <span class="keyword">if</span> (sourceStats == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// 512 element window (4 kb)</span></div><div class="line">      sourceStats = <span class="keyword">new</span> DescriptiveStatistics(<span class="keyword">this</span>.historySize);</div><div class="line">      latencyStats.put(sourceDescriptor, sourceStats);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line">   sourceStats.addValue(now - marker.getMarkedTime());  <span class="comment">//所以latency的计算时间是当前时间减去marker摄入的时间</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="number">1</span>.首先生成一个Latency的描述符，sink operator的区分不同subIndex为不同LatencySource，其他operator不区分subIndex，只按照vertexID来区分</div><div class="line"><span class="number">2</span>.然后生成对应Latency的描述符的最近<span class="string">"historySize:128"</span>个Latency的值（WindowSize controls the number of values that contribute to the reported statistics. ）</div><div class="line"><span class="number">3</span>.在这里值没有在web展示的原因是因为guage展示的不是一个数字，因而无法被展示</div></pre></td></tr></table></figure>
<p>然后只要不是sink类型的operator，就会往后继续传递LatencyMarker。随机选择一个Channel来发送,这里就是为了保证一个latencyMarker在整个流中只会出现一次。这里和watermark的机制有点不一样，waterMark是遍历全部的channel来发送。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emitLatencyMarker</span><span class="params">(LatencyMarker latencyMarker)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span>(outputs.length &lt;= <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// ignore</span></div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>(outputs.length == <span class="number">1</span>) &#123;</div><div class="line">      outputs[<span class="number">0</span>].emitLatencyMarker(latencyMarker);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// randomly select an output</span></div><div class="line">      outputs[RNG.nextInt(outputs.length)].emitLatencyMarker(latencyMarker);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>LatencyMarker不会参与窗口时间的计算，应该说是不参与任何operator的计算，因此他只能用来衡量数据在整个DAG中流通的速度不能衡量operator计算的时间，这个只能通过单测来进行计算</strong><br><code>StreamInputProcessor#processInput</code>  这里进行对进入的element进行处理，对于watermark和LatencyMarker类型会先处理发送掉，不会经由后面的windowOperator或其他operator来处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (result.isFullRecord()) &#123;</div><div class="line">   StreamElement recordOrMark = deserializationDelegate.getInstance();</div><div class="line"> </div><div class="line">   <span class="keyword">if</span> (recordOrMark.isWatermark()) &#123;</div><div class="line">      <span class="keyword">long</span> watermarkMillis = recordOrMark.asWatermark().getTimestamp();</div><div class="line">      <span class="keyword">if</span> (watermarkMillis &gt; watermarks[currentChannel]) &#123;</div><div class="line">         watermarks[currentChannel] = watermarkMillis;</div><div class="line">         <span class="keyword">long</span> newMinWatermark = Long.MAX_VALUE;</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">long</span> watermark: watermarks) &#123;</div><div class="line">            newMinWatermark = Math.min(watermark, newMinWatermark);</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (newMinWatermark &gt; lastEmittedWatermark) &#123;</div><div class="line">            lastEmittedWatermark = newMinWatermark;</div><div class="line">            <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">               streamOperator.processWatermark(<span class="keyword">new</span> Watermark(lastEmittedWatermark));</div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>(recordOrMark.isLatencyMarker()) &#123;</div><div class="line">      <span class="comment">// handle latency marker</span></div><div class="line">      <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">         streamOperator.processLatencyMarker(recordOrMark.asLatencyMarker());</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// now we can do the actual processing</span></div><div class="line">      StreamRecord&lt;IN&gt; record = recordOrMark.asRecord();</div><div class="line">      <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">         numRecordsIn.inc();</div><div class="line">         streamOperator.setKeyContextElement1(record);</div><div class="line">         streamOperator.processElement(record);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>sink中只进行report不再进行forward了（StreamSink.java）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reportOrForwardLatencyMarker</span><span class="params">(LatencyMarker maker)</span> </span>&#123;</div><div class="line">   <span class="comment">// all operators are tracking latencies</span></div><div class="line">   <span class="keyword">this</span>.latencyGauge.reportLatency(maker, <span class="keyword">true</span>);</div><div class="line"> </div><div class="line">   <span class="comment">// sinks don't forward latency markers</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>LatencyMarker能够较好的监控因网络抖动或数据反压引起的延迟，可以提前预警反压情况</li>
<li>在正常情况（没有反压）下数据在DAG图中的流动延迟大概0.5s左右，所以说Flink的确是一个很快的引擎：）</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Flink中的Latency track&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Flink" scheme="yoursite.com/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>Hexo tutorial</title>
    <link href="yoursite.com/2016/10/12/hello-world/"/>
    <id>yoursite.com/2016/10/12/hello-world/</id>
    <published>2016-10-11T16:47:35.000Z</published>
    <updated>2017-09-10T07:02:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 写文章常用语法</p>
<a id="more"></a>
<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<p>###Create a page </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new page tags</div></pre></td></tr></table></figure>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo 写文章常用语法&lt;/p&gt;
    
    </summary>
    
      <category term="常用命令" scheme="yoursite.com/categories/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="hexo" scheme="yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
